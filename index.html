
<!DOCTYPE html>
<html>
<head>
    <title>Submission</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }
        h1 {
            text-align: center;
        }
        table {
            width: 100%;
            border-collapse: collapse;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 10px;
            vertical-align: top;
        }
        th {
            background-color: #f4f4f4;
        }
        td {
            width: 50%;
        }
        .description {
            width: 100%;
        }
        .code {
            width:100%;
            height:100%;
            background-color: #f4f4f4;
            border: 1px solid #ddd;
            padding: 1px;
            border-radius: 5px;
            white-space: pre-wrap;
            font-family: 'Courier New', Courier, monospace;
        }
        
        
    </style>
    <style>pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.highlight .hll { background-color: #ffffcc }
.highlight { background: #f8f8f8; }
.highlight .c { color: #3D7B7B; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.highlight .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #9C6500 } /* Comment.Preproc */
.highlight .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.highlight .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.highlight .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #E40000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #008400 } /* Generic.Inserted */
.highlight .go { color: #717171 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0044DD } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #687822 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #717171; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #767600 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mb { color: #666666 } /* Literal.Number.Bin */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sa { color: #BA2121 } /* Literal.String.Affix */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .dl { color: #BA2121 } /* Literal.String.Delimiter */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #A45A77 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .fm { color: #0000FF } /* Name.Function.Magic */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .vm { color: #19177C } /* Name.Variable.Magic */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */</style>
</head>
<body>
    <h1>All submissions</h1>
<div class="solution">
    <center><h2>0.Spiral Matrix</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>0.Spiral Matrix</h2>
                <p>Given an m x n matrix, return all elements of the matrix in spiral order.<br> <br>Example 1:<br><br><br>Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]<br>Output: [1,2,3,6,9,8,7,4,5]<br><br>Example 2:<br><br><br>Input: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]<br>Output: [1,2,3,4,8,12,11,10,9,5,6,7]<br><br> <br>Constraints:<br><br>m == matrix.length<br>n == matrix[i].length<br>1 <= m, n <= 10<br>-100 <= matrix[i][j] <= 100<br><br></p>
                <a href=https://leetcode.com/problems/spiral-matrix>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    
    <span class="k">def</span> <span class="nf">print_outer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">,</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">ROWS</span><span class="p">,</span> <span class="n">COLS</span><span class="p">,</span> <span class="n">output</span><span class="p">):</span>
        <span class="c1"># print top row</span>
        <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;--------&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">COLS</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">output</span><span class="o">.</span><span class="n">append</span> <span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>
        <span class="nb">print</span> <span class="p">(</span><span class="n">output</span><span class="p">)</span>
        
        <span class="c1">#print (&quot;right rowd&quot;)</span>
        <span class="c1"># print right column</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">ROWS</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">COLS</span><span class="p">])</span>
        <span class="nb">print</span> <span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">ROWS</span><span class="p">,</span> <span class="n">COLS</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">)</span>
        <span class="c1"># print bottom row</span>
        <span class="c1">#R, C 1 2 .... r, c =1 1</span>
        <span class="k">if</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">ROWS</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">COLS</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">output</span><span class="o">.</span><span class="n">append</span> <span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="n">ROWS</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>
        <span class="nb">print</span> <span class="p">(</span><span class="n">output</span><span class="p">)</span>
        <span class="c1"># print left column</span>
        <span class="k">if</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">COLS</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">ROWS</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">output</span><span class="o">.</span><span class="n">append</span> <span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">r</span><span class="p">])</span>
        <span class="nb">print</span> <span class="p">(</span><span class="n">output</span><span class="p">)</span>
        

    <span class="k">def</span> <span class="nf">spiralOrder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">matrix</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ROWS</span><span class="p">,</span> <span class="n">COLS</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span>
        <span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span> 
        <span class="k">while</span> <span class="n">r</span> <span class="o">&lt;=</span> <span class="n">ROWS</span> <span class="ow">and</span> <span class="n">c</span><span class="o">&lt;=</span><span class="n">COLS</span><span class="p">:</span>
            <span class="nb">print</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">,</span> <span class="n">ROWS</span><span class="p">,</span> <span class="n">COLS</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">print_outer</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">,</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">ROWS</span><span class="p">,</span> <span class="n">COLS</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>
            <span class="n">r</span> <span class="o">+=</span><span class="mi">1</span>
            <span class="n">c</span> <span class="o">+=</span><span class="mi">1</span>
            <span class="n">ROWS</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="n">COLS</span> <span class="o">-=</span> <span class="mi">1</span>

            
        <span class="k">return</span> <span class="n">output</span>




        
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>1.Number of Islands</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>1.Number of Islands</h2>
                <p>Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.<br>An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.<br> <br>Example 1:<br><br>Input: grid = [<br>  ["1","1","1","1","0"],<br>  ["1","1","0","1","0"],<br>  ["1","1","0","0","0"],<br>  ["0","0","0","0","0"]<br>]<br>Output: 1<br><br>Example 2:<br><br>Input: grid = [<br>  ["1","1","0","0","0"],<br>  ["1","1","0","0","0"],<br>  ["0","0","1","0","0"],<br>  ["0","0","0","1","1"]<br>]<br>Output: 3<br><br> <br>Constraints:<br><br>m == grid.length<br>n == grid[i].length<br>1 <= m, n <= 300<br>grid[i][j] is '0' or '1'.<br><br></p>
                <a href=https://leetcode.com/problems/number-of-islands>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">numIslands</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">ROWS</span><span class="p">,</span> <span class="n">COLS</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="p">[[</span> <span class="kc">False</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">COLS</span><span class="p">)]</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ROWS</span><span class="p">)]</span>
        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">pos</span><span class="p">):</span>
            <span class="n">r</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">pos</span>

            <span class="k">if</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">r</span> <span class="o">&gt;=</span> <span class="n">ROWS</span> <span class="ow">or</span> <span class="n">c</span><span class="o">&lt;</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">c</span><span class="o">&gt;=</span><span class="n">COLS</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="k">if</span> <span class="n">grid</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;0&quot;</span> <span class="ow">or</span> <span class="n">visited</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]:</span>
                <span class="k">return</span> 
            <span class="n">visited</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">for</span> <span class="n">dr</span><span class="p">,</span> <span class="n">dc</span> <span class="ow">in</span> <span class="p">[</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]:</span>
                <span class="n">r1</span><span class="p">,</span> <span class="n">c1</span> <span class="o">=</span> <span class="n">r</span><span class="o">+</span><span class="n">dr</span><span class="p">,</span> <span class="n">c</span><span class="o">+</span><span class="n">dc</span>
                <span class="n">dfs</span><span class="p">((</span><span class="n">r1</span><span class="p">,</span><span class="n">c1</span><span class="p">))</span>

        <span class="n">num_islands</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ROWS</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">COLS</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">grid</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;1&quot;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">visited</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]:</span>
                    <span class="n">dfs</span><span class="p">((</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">))</span>
                    <span class="n">num_islands</span> <span class="o">+=</span><span class="mi">1</span>
        
        <span class="k">return</span> <span class="n">num_islands</span>
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>2.Longest Continuous Increasing Subsequence</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>2.Longest Continuous Increasing Subsequence</h2>
                <p>Given an unsorted array of integers nums, return the length of the longest continuous increasing subsequence (i.e. subarray). The subsequence must be strictly increasing.<br>A continuous increasing subsequence is defined by two indices l and r (l < r) such that it is [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] and for each l <= i < r, nums[i] < nums[i + 1].<br> <br>Example 1:<br><br>Input: nums = [1,3,5,4,7]<br>Output: 3<br>Explanation: The longest continuous increasing subsequence is [1,3,5] with length 3.<br>Even though [1,3,5,7] is an increasing subsequence, it is not continuous as elements 5 and 7 are separated by element<br>4.<br><br>Example 2:<br><br>Input: nums = [2,2,2,2,2]<br>Output: 1<br>Explanation: The longest continuous increasing subsequence is [2] with length 1. Note that it must be strictly<br>increasing.<br><br> <br>Constraints:<br><br>1 <= nums.length <= 104<br>-109 <= nums[i] <= 109<br><br></p>
                <a href=https://leetcode.com/problems/longest-continuous-increasing-subsequence>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="n">public</span><span class="p">:</span>
    <span class="nb">int</span> <span class="n">findLengthOfLCIS</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
        <span class="nb">int</span> <span class="n">max_size</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="nb">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">end</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">end</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="n">size</span><span class="p">();</span> <span class="n">end</span><span class="o">++</span><span class="p">){</span>
            <span class="k">if</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">end</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">end</span><span class="o">-</span><span class="mi">1</span><span class="p">]){</span>
                <span class="nb">int</span> <span class="n">c_size</span> <span class="o">=</span> <span class="n">end</span><span class="o">-</span><span class="n">start</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
                <span class="n">max_size</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">c_size</span><span class="p">,</span> <span class="n">max_size</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">else</span><span class="p">{</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">max_size</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>3.Longest Repeating Character Replacement</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>3.Longest Repeating Character Replacement</h2>
                <p>You are given a string s and an integer k. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most k times.<br>Return the length of the longest substring containing the same letter you can get after performing the above operations.<br> <br>Example 1:<br><br>Input: s = "ABAB", k = 2<br>Output: 4<br>Explanation: Replace the two 'A's with two 'B's or vice versa.<br><br>Example 2:<br><br>Input: s = "AABABBA", k = 1<br>Output: 4<br>Explanation: Replace the one 'A' in the middle with 'B' and form "AABBBBA".<br>The substring "BBBB" has the longest repeating letters, which is 4.<br>There may exists other ways to achieve this answer too.<br> <br>Constraints:<br><br>1 <= s.length <= 105<br>s consists of only uppercase English letters.<br>0 <= k <= s.length<br><br></p>
                <a href=https://leetcode.com/problems/longest-repeating-character-replacement>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">characterReplacement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">longest_str</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">freq_char</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)):</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">e</span><span class="p">]</span>
            <span class="n">freq_char</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">freq_char</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">0</span> <span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="n">most_freq</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">freq_char</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="n">freq_char</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
            <span class="n">remain_char_freq</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">freq_char</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">key</span><span class="o">!=</span> <span class="n">most_freq</span><span class="p">:</span>
                    <span class="n">remain_char_freq</span> <span class="o">+=</span> <span class="n">v</span>
            <span class="c1">#print (start, e , freq_char, most_freq)</span>
            <span class="k">while</span> <span class="n">remain_char_freq</span> <span class="o">&gt;</span> <span class="n">k</span><span class="p">:</span>

               <span class="c1">#print (start, e , freq_char, most_freq)</span>
                <span class="n">freq_char</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">start</span><span class="p">]]</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">freq_char</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">start</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">:</span>
                    <span class="k">del</span> <span class="n">freq_char</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">start</span><span class="p">]]</span>
                <span class="n">start</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="n">most_freq</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">freq_char</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="n">freq_char</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
                <span class="n">remain_char_freq</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">freq_char</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">key</span><span class="o">!=</span> <span class="n">most_freq</span><span class="p">:</span>
                        <span class="n">remain_char_freq</span> <span class="o">+=</span> <span class="n">v</span>

            <span class="c1"># if remain_char_freq &lt;= k:</span>
            <span class="n">longest_str</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">e</span><span class="o">-</span><span class="n">start</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">longest_str</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">longest_str</span>
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>4.Longest Consecutive Sequence</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>4.Longest Consecutive Sequence</h2>
                <p>Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence.<br>You must write an algorithm that runs in O(n) time.<br> <br>Example 1:<br><br>Input: nums = [100,4,200,1,3,2]<br>Output: 4<br>Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.<br><br>Example 2:<br><br>Input: nums = [0,3,7,2,5,8,4,6,0,1]<br>Output: 9<br><br> <br>Constraints:<br><br>0 <= nums.length <= 105<br>-109 <= nums[i] <= 109<br><br></p>
                <a href=https://leetcode.com/problems/longest-consecutive-sequence>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">longestConsecutive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">max_len</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">idxs_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">num</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
            <span class="n">idxs_dict</span><span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>

        <span class="n">max_len_num</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">def</span> <span class="nf">get_greater_cons</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">num</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">idxs_dict</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>

            <span class="k">if</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">max_len_num</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">max_len_num</span><span class="p">[</span><span class="n">num</span><span class="p">]</span>
            
            <span class="n">max_len_num</span><span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="o">=</span>  <span class="n">get_greater_cons</span><span class="p">(</span><span class="n">num</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">max_len_num</span><span class="p">[</span><span class="n">num</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">num</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
            <span class="n">max_len</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span> <span class="n">get_greater_cons</span><span class="p">(</span><span class="n">num</span><span class="p">),</span> <span class="n">max_len</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">max_len</span>
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>5.Missing Number</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>5.Missing Number</h2>
                <p>Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.<br> <br>Example 1:<br><br>Input: nums = [3,0,1]<br>Output: 2<br>Explanation: n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums.<br><br>Example 2:<br><br>Input: nums = [0,1]<br>Output: 2<br>Explanation: n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums.<br><br>Example 3:<br><br>Input: nums = [9,6,4,2,3,5,7,0,1]<br>Output: 8<br>Explanation: n = 9 since there are 9 numbers, so all numbers are in the range [0,9]. 8 is the missing number in the range since it does not appear in nums.<br><br> <br>Constraints:<br><br>n == nums.length<br>1 <= n <= 104<br>0 <= nums[i] <= n<br>All the numbers of nums are unique.<br><br> <br>Follow up: Could you implement a solution using only O(1) extra space complexity and O(n) runtime complexity?<br></p>
                <a href=https://leetcode.com/problems/missing-number>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">missingNumber</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">missing</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
            <span class="n">missing</span> <span class="o">^=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">^</span> <span class="n">i</span>

        

        <span class="k">return</span> <span class="n">missing</span>

        
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>6.Add Binary</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>6.Add Binary</h2>
                <p>Given two binary strings a and b, return their sum as a binary string.<br> <br>Example 1:<br>Input: a = "11", b = "1"<br>Output: "100"<br>Example 2:<br>Input: a = "1010", b = "1011"<br>Output: "10101"<br><br> <br>Constraints:<br><br>1 <= a.length, b.length <= 104<br>a and b consist only of '0' or '1' characters.<br>Each string does not contain leading zeros except for the zero itself.<br><br></p>
                <a href=https://leetcode.com/problems/add-binary>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">addBinary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        a = &quot;1010&quot;, b = &quot;1011&quot;</span>
<span class="sd">        0101</span>
<span class="sd">        1101</span>
<span class="sd">        0011. , 1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">n2</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">n1</span><span class="o">&gt;</span><span class="n">n2</span><span class="p">:</span>
            <span class="n">b</span> <span class="o">+=</span> <span class="s2">&quot;0&quot;</span><span class="o">*</span><span class="p">(</span><span class="n">n1</span><span class="o">-</span><span class="n">n2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">+=</span> <span class="s2">&quot;0&quot;</span><span class="o">*</span><span class="p">(</span><span class="n">n2</span><span class="o">-</span><span class="n">n1</span><span class="p">)</span>
        
        <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">out</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span><span class="n">n2</span><span class="p">)):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            1. 1   0 =&gt; 0, 1</span>
<span class="sd">                   1 =&gt; 1, 1</span>
<span class="sd">            0. 0   0 =&gt; 0, 0</span>
<span class="sd">                   1 =&gt; 1, 0</span>
<span class="sd">            0. 1   1 =&gt; 0, 0   =&gt; 0, 1</span>
<span class="sd">                   0 =&gt; 1, 0</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>       
            <span class="n">s</span> <span class="o">=</span> <span class="n">x</span> <span class="o">^</span> <span class="n">y</span> <span class="o">^</span> <span class="n">c</span>
            
            <span class="k">if</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="o">+</span><span class="n">c</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1">#s = 0</span>
                <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">elif</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="o">+</span><span class="n">c</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1">#s = 1</span>
                <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">elif</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="o">+</span><span class="n">c</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1">#s = 0</span>
                <span class="n">c</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">out</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="nb">print</span> <span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">c</span><span class="p">:</span>
            <span class="n">out</span><span class="o">+=</span><span class="nb">str</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">out</span>
            
                
            
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>7.Longest Common Subsequence</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>7.Longest Common Subsequence</h2>
                <p>Given two strings text1 and text2, return the length of their longest common subsequence. If there is no common subsequence, return 0.<br>A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.<br><br>For example, "ace" is a subsequence of "abcde".<br><br>A common subsequence of two strings is a subsequence that is common to both strings.<br> <br>Example 1:<br><br>Input: text1 = "abcde", text2 = "ace" <br>Output: 3  <br>Explanation: The longest common subsequence is "ace" and its length is 3.<br><br>Example 2:<br><br>Input: text1 = "abc", text2 = "abc"<br>Output: 3<br>Explanation: The longest common subsequence is "abc" and its length is 3.<br><br>Example 3:<br><br>Input: text1 = "abc", text2 = "def"<br>Output: 0<br>Explanation: There is no such common subsequence, so the result is 0.<br><br> <br>Constraints:<br><br>1 <= text1.length, text2.length <= 1000<br>text1 and text2 consist of only lowercase English characters.<br><br></p>
                <a href=https://leetcode.com/problems/longest-common-subsequence>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">lcs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span> <span class="o">==</span> <span class="n">i</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s1</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">!=-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>

        <span class="n">c_lcs</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">s1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">s2</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
            <span class="n">c_lcs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lcs</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">c_lcs</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lcs</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lcs</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">c_lcs</span>
        <span class="k">return</span> <span class="n">c_lcs</span>
    
    <span class="k">def</span> <span class="nf">longestCommonSubsequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text1</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">text2</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dp</span> <span class="o">=</span> <span class="p">[[</span><span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">text2</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">text1</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">lcs</span><span class="p">(</span><span class="n">text1</span><span class="p">,</span> <span class="n">text2</span><span class="p">,</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>8.Remove Duplicates from Sorted Array</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>8.Remove Duplicates from Sorted Array</h2>
                <p>Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in nums.<br>Consider the number of unique elements of nums to be k, to get accepted, you need to do the following things:<br><br>Change the array nums such that the first k elements of nums contain the unique elements in the order they were present in nums initially. The remaining elements of nums are not important as well as the size of nums.<br>Return k.<br><br>Custom Judge:<br>The judge will test your solution with the following code:<br><br>int[] nums = [...]; // Input array<br>int[] expectedNums = [...]; // The expected answer with correct length<br><br>int k = removeDuplicates(nums); // Calls your implementation<br><br>assert k == expectedNums.length;<br>for (int i = 0; i < k; i++) {<br>    assert nums[i] == expectedNums[i];<br>}<br><br>If all assertions pass, then your solution will be accepted.<br> <br>Example 1:<br><br>Input: nums = [1,1,2]<br>Output: 2, nums = [1,2,_]<br>Explanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.<br>It does not matter what you leave beyond the returned k (hence they are underscores).<br><br>Example 2:<br><br>Input: nums = [0,0,1,1,1,2,2,3,3,4]<br>Output: 5, nums = [0,1,2,3,4,_,_,_,_,_]<br>Explanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.<br>It does not matter what you leave beyond the returned k (hence they are underscores).<br><br> <br>Constraints:<br><br>1 <= nums.length <= 3 * 104<br>-100 <= nums[i] <= 100<br>nums is sorted in non-decreasing order.<br><br></p>
                <a href=https://leetcode.com/problems/remove-duplicates-from-sorted-array>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="n">public</span><span class="p">:</span>
<span class="o">//</span> <span class="s2">&quot;&quot;&quot;</span>

<span class="s2">// [0,0,1,1,1,2,2,3,3,4]</span>
<span class="s2">// [0,1,2,1,3,1,2,2  ]</span>
<span class="s2">//.       i </span>

<span class="s2">// &quot;&quot;&quot;</span>
    <span class="nb">int</span> <span class="n">removeDuplicates</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
        <span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="nb">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="n">size</span><span class="p">();</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]){</span>

            <span class="p">}</span>
            <span class="k">else</span><span class="p">{</span>
                <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
                <span class="n">i</span><span class="o">+=</span><span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>9.Longest Palindromic Substring</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>9.Longest Palindromic Substring</h2>
                <p>Given a string s, return the longest palindromic substring in s.<br> <br>Example 1:<br><br>Input: s = "babad"<br>Output: "bab"<br>Explanation: "aba" is also a valid answer.<br><br>Example 2:<br><br>Input: s = "cbbd"<br>Output: "bb"<br><br> <br>Constraints:<br><br>1 <= s.length <= 1000<br>s consist of only digits and English letters.<br><br></p>
                <a href=https://leetcode.com/problems/longest-palindromic-substring>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd"> c b b d</span>
<span class="sd">[1 0 0 0],c</span>
<span class="sd">[0 1 0 0],b</span>
<span class="sd">[0 0 1 0],b</span>
<span class="sd">[0 0 0 1],d</span>

<span class="sd">2</span>
<span class="sd">-&gt; 0,1   (1,2), (2,3), *</span>
<span class="sd">3</span>
<span class="sd">4</span>
<span class="sd">5</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    
    <span class="k">def</span> <span class="nf">longestPalindrome</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="c1"># longest palindrome</span>
        <span class="n">dp</span> <span class="o">=</span> <span class="p">[[</span><span class="kc">True</span> <span class="k">if</span> <span class="n">i</span><span class="o">==</span><span class="n">j</span> <span class="k">else</span> <span class="kc">False</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">))]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">))]</span>
        <span class="n">longest_substr</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">-</span><span class="n">k</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">k</span><span class="p">]</span> <span class="ow">and</span> <span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="o">==</span><span class="mi">2</span> <span class="ow">or</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="o">+</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="o">+</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="c1"># substr = s[i:i+k+1] </span>
                    <span class="k">if</span> <span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">ans</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">ans</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                        <span class="n">ans</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="n">k</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="o">+</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="o">=</span> <span class="n">ans</span>
        <span class="n">longest_substr</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">longest_substr</span>

    <span class="k">def</span> <span class="nf">longestPalindrome1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">expand</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
            <span class="n">substr</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
            <span class="k">while</span> <span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">j</span><span class="o">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">!=</span><span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                    <span class="k">break</span>
                <span class="n">ans</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
                <span class="n">i</span><span class="o">-=</span><span class="mi">1</span>
                <span class="n">j</span><span class="o">+=</span><span class="mi">1</span>
            <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="o">=</span> <span class="n">ans</span>
            <span class="n">substr</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">substr</span>

        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="n">longest_substr</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)):</span>
            <span class="n">substr</span> <span class="o">=</span> <span class="n">expand</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">substr</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">longest_substr</span><span class="p">):</span>
                <span class="n">longest_substr</span> <span class="o">=</span> <span class="n">substr</span>
            <span class="n">substr</span><span class="o">=</span> <span class="n">expand</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">substr</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">longest_substr</span><span class="p">):</span>
                <span class="n">longest_substr</span> <span class="o">=</span> <span class="n">substr</span>
            <span class="c1">#print (substr)</span>
        <span class="k">return</span> <span class="n">longest_substr</span>
                
        
        
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>10.Merge Intervals</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>10.Merge Intervals</h2>
                <p>Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.<br> <br>Example 1:<br><br>Input: intervals = [[1,3],[2,6],[8,10],[15,18]]<br>Output: [[1,6],[8,10],[15,18]]<br>Explanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].<br><br>Example 2:<br><br>Input: intervals = [[1,4],[4,5]]<br>Output: [[1,5]]<br>Explanation: Intervals [1,4] and [4,5] are considered overlapping.<br><br> <br>Constraints:<br><br>1 <= intervals.length <= 104<br>intervals[i].length == 2<br>0 <= starti <= endi <= 104<br><br></p>
                <a href=https://leetcode.com/problems/merge-intervals>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">intervals</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="n">sorted_intervals</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sorted_intervals</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">sorted_intervals</span><span class="p">)):</span>
            <span class="n">prev_interval</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">ps</span><span class="p">,</span> <span class="n">pe</span> <span class="o">=</span> <span class="n">prev_interval</span>

            <span class="n">cs</span><span class="p">,</span> <span class="n">ce</span> <span class="o">=</span> <span class="n">sorted_intervals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">cs</span> <span class="o">&lt;=</span> <span class="n">pe</span><span class="p">:</span>
                <span class="c1"># overlapping, the merge</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">ps</span>
                <span class="n">e</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ce</span><span class="p">,</span> <span class="n">pe</span><span class="p">)</span>
                <span class="n">output</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="p">,</span><span class="n">e</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">[</span><span class="n">cs</span><span class="p">,</span> <span class="n">ce</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">output</span>
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>11.Minimum Remove to Make Valid Parentheses</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>11.Minimum Remove to Make Valid Parentheses</h2>
                <p>Given a string s of '(' , ')' and lowercase English characters.<br>Your task is to remove the minimum number of parentheses ( '(' or ')', in any positions ) so that the resulting parentheses string is valid and return any valid string.<br>Formally, a parentheses string is valid if and only if:<br><br>It is the empty string, contains only lowercase characters, or<br>It can be written as AB (A concatenated with B), where A and B are valid strings, or<br>It can be written as (A), where A is a valid string.<br><br> <br>Example 1:<br><br>Input: s = "lee(t(c)o)de)"<br>Output: "lee(t(c)o)de"<br>Explanation: "lee(t(co)de)" , "lee(t(c)ode)" would also be accepted.<br><br>Example 2:<br><br>Input: s = "a)b(c)d"<br>Output: "ab(c)d"<br><br>Example 3:<br><br>Input: s = "))(("<br>Output: ""<br>Explanation: An empty string is also valid.<br><br> <br>Constraints:<br><br>1 <= s.length <= 105<br>s[i] is either '(' , ')', or lowercase English letter.<br><br></p>
                <a href=https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">minRemoveToMakeValid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span> 
        <span class="n">output</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">c</span><span class="o">==</span><span class="s2">&quot;(&quot;</span><span class="p">:</span>
                <span class="n">count</span> <span class="o">+=</span><span class="mi">1</span>
            <span class="k">elif</span> <span class="n">c</span><span class="o">==</span><span class="s2">&quot;)&quot;</span><span class="p">:</span>
                <span class="n">count</span> <span class="o">-=</span><span class="mi">1</span>
            <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">output</span> <span class="o">+=</span> <span class="n">c</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="nb">print</span> <span class="p">(</span><span class="n">output</span><span class="p">)</span>
        <span class="n">output1</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">output</span><span class="p">))</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span> 
        <span class="n">output</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">output1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">c</span><span class="o">==</span><span class="s2">&quot;)&quot;</span><span class="p">:</span>
                <span class="n">count</span> <span class="o">+=</span><span class="mi">1</span>
            <span class="k">elif</span> <span class="n">c</span><span class="o">==</span><span class="s2">&quot;(&quot;</span><span class="p">:</span>
                <span class="n">count</span> <span class="o">-=</span><span class="mi">1</span>
            <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">output</span> <span class="o">+=</span> <span class="n">c</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">output</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">output</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">output</span>
        
            
            
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>12.LRU Cache</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>12.LRU Cache</h2>
                <p>Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.<br>Implement the LRUCache class:<br><br>LRUCache(int capacity) Initialize the LRU cache with positive size capacity.<br>int get(int key) Return the value of the key if the key exists, otherwise return -1.<br>void put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.<br><br>The functions get and put must each run in O(1) average time complexity.<br> <br>Example 1:<br><br>Input<br>["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]<br>[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]<br>Output<br>[null, null, null, 1, null, -1, null, -1, 3, 4]<br><br>Explanation<br>LRUCache lRUCache = new LRUCache(2);<br>lRUCache.put(1, 1); // cache is {1=1}<br>lRUCache.put(2, 2); // cache is {1=1, 2=2}<br>lRUCache.get(1);    // return 1<br>lRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}<br>lRUCache.get(2);    // returns -1 (not found)<br>lRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}<br>lRUCache.get(1);    // return -1 (not found)<br>lRUCache.get(3);    // return 3<br>lRUCache.get(4);    // return 4<br><br> <br>Constraints:<br><br>1 <= capacity <= 3000<br>0 <= key <= 104<br>0 <= value <= 105<br>At most 2 * 105 calls will be made to get and put.<br><br></p>
                <a href=https://leetcode.com/problems/lru-cache>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>

<span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">key</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="kc">None</span>
    
<span class="k">class</span> <span class="nc">OrderedDict1</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tail</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_dict</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_dict</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_dict</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">val</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="n">prev_node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span>
        <span class="n">next_node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">tail</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tail</span> <span class="o">=</span> <span class="kc">None</span>
            
        <span class="k">elif</span> <span class="n">prev_node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">next_node</span>
        <span class="k">elif</span> <span class="n">next_node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">prev_node</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tail</span> <span class="o">=</span> <span class="n">prev_node</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">prev_node</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">next_node</span>
            <span class="n">next_node</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">prev_node</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        
    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="nb">print</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">node</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tail</span> <span class="o">=</span> <span class="n">node</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">tail</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">node</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tail</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tail</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">node</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tail</span> <span class="o">=</span> <span class="n">node</span>
        
        <span class="nb">print</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    
    <span class="k">def</span> <span class="nf">popitem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">last</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="n">first_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span><span class="o">.</span><span class="n">right</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_dict</span><span class="p">[</span><span class="n">first_node</span><span class="o">.</span><span class="n">key</span><span class="p">]</span>

<span class="k">class</span> <span class="nc">LRUCache</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">capacity</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">capacity</span> <span class="o">=</span> <span class="n">capacity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cache</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">return</span> <span class="n">value</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
        

    <span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">capacity</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">popitem</span><span class="p">(</span><span class="n">last</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>


<span class="c1"># Your LRUCache object will be instantiated and called as such:</span>
<span class="c1"># obj = LRUCache(capacity)</span>
<span class="c1"># param_1 = obj.get(key)</span>
<span class="c1"># obj.put(key,value)</span>
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>13.Sum of Two Integers</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>13.Sum of Two Integers</h2>
                <p>Given two integers a and b, return the sum of the two integers without using the operators + and -.<br> <br>Example 1:<br>Input: a = 1, b = 2<br>Output: 3<br>Example 2:<br>Input: a = 2, b = 3<br>Output: 5<br><br> <br>Constraints:<br><br>-1000 <= a, b <= 1000<br><br></p>
                <a href=https://leetcode.com/problems/sum-of-two-integers>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">getSum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="c1"># s = a</span>
        <span class="c1"># c = b</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="mh">0xffff</span>
        <span class="k">while</span> <span class="n">b</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">^</span> <span class="n">b</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span>
            <span class="n">c</span> <span class="o">=</span> <span class="p">((</span><span class="n">a</span> <span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span>


            <span class="n">a</span> <span class="o">=</span> <span class="n">s</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">c</span>

        <span class="k">if</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">mask</span><span class="o">//</span><span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">~</span><span class="p">(</span><span class="n">a</span> <span class="o">^</span> <span class="n">mask</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">a</span> 
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>14.Valid Parentheses</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>14.Valid Parentheses</h2>
                <p>Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.<br>An input string is valid if:<br><br>Open brackets must be closed by the same type of brackets.<br>Open brackets must be closed in the correct order.<br>Every close bracket has a corresponding open bracket of the same type.<br><br> <br>Example 1:<br><br>Input: s = "()"<br>Output: true<br><br>Example 2:<br><br>Input: s = "()[]{}"<br>Output: true<br><br>Example 3:<br><br>Input: s = "(]"<br>Output: false<br><br> <br>Constraints:<br><br>1 <= s.length <= 104<br>s consists of parentheses only '()[]{}'.<br><br></p>
                <a href=https://leetcode.com/problems/valid-parentheses>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">isValid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (} </span>

<span class="sd">        ({)}        &quot;&quot;&quot;</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">pairs</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;)&quot;</span> <span class="p">:</span> <span class="s2">&quot;(&quot;</span><span class="p">,</span>
            <span class="s2">&quot;]&quot;</span> <span class="p">:</span> <span class="s2">&quot;[&quot;</span><span class="p">,</span>
            <span class="s2">&quot;}&quot;</span> <span class="p">:</span> <span class="s2">&quot;{&quot;</span>
         <span class="p">}</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;(&quot;</span><span class="p">,</span> <span class="s2">&quot;{&quot;</span><span class="p">,</span> <span class="s2">&quot;[&quot;</span><span class="p">]:</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span> <span class="ow">and</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">pairs</span><span class="p">[</span><span class="n">c</span><span class="p">]:</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span> <span class="p">:</span> <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>15.Next Permutation</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>15.Next Permutation</h2>
                <p>A permutation of an array of integers is an arrangement of its members into a sequence or linear order.<br><br>For example, for arr = [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1].<br><br>The next permutation of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).<br><br>For example, the next permutation of arr = [1,2,3] is [1,3,2].<br>Similarly, the next permutation of arr = [2,3,1] is [3,1,2].<br>While the next permutation of arr = [3,2,1] is [1,2,3] because [3,2,1] does not have a lexicographical larger rearrangement.<br><br>Given an array of integers nums, find the next permutation of nums.<br>The replacement must be in place and use only constant extra memory.<br> <br>Example 1:<br><br>Input: nums = [1,2,3]<br>Output: [1,3,2]<br><br>Example 2:<br><br>Input: nums = [3,2,1]<br>Output: [1,2,3]<br><br>Example 3:<br><br>Input: nums = [1,1,5]<br>Output: [1,5,1]<br><br> <br>Constraints:<br><br>1 <= nums.length <= 100<br>0 <= nums[i] <= 100<br><br></p>
                <a href=https://leetcode.com/problems/next-permutation>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="n">public</span><span class="p">:</span>
<span class="o">//</span>     <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="o">-&gt;</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">5</span> <span class="mi">4</span><span class="o">-</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">4</span> <span class="mi">3</span> <span class="mi">5</span> <span class="o">-&gt;</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">3</span> <span class="o">-&gt;</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">5</span> <span class="mi">4</span> <span class="mi">3</span> <span class="o">-&gt;</span> <span class="mi">1</span> <span class="mi">3</span> <span class="mi">2</span> <span class="mi">5</span> <span class="mi">4</span>
<span class="o">//</span>     <span class="mi">3</span> <span class="mi">2</span> <span class="mi">1</span> <span class="mi">4</span> <span class="mi">5</span>
<span class="o">//</span>     <span class="mi">1</span> <span class="mi">2</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">3</span>
    <span class="n">void</span> <span class="n">nextPermutation</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
        <span class="nb">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">i</span><span class="o">=</span><span class="n">nums</span><span class="o">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span><span class="mi">0</span> <span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">){</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]){</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">){</span>
            <span class="n">reverse</span><span class="p">(</span><span class="n">nums</span><span class="o">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">nums</span><span class="o">.</span><span class="n">end</span><span class="p">());</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="o">//</span> <span class="n">find</span> <span class="nb">next</span> <span class="n">greater</span> <span class="n">element</span>
        <span class="nb">int</span> <span class="n">insert_elem</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
        <span class="nb">int</span> <span class="n">next_largest</span> <span class="o">=</span> <span class="mi">101</span><span class="p">;</span>
        <span class="nb">int</span> <span class="n">next_largest_idx</span> <span class="o">=</span> <span class="mi">101</span><span class="p">;</span>
        
        
        <span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">idx</span><span class="p">;</span>
        <span class="nb">int</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
        <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">nums</span><span class="o">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">insert_elem</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">next_largest</span><span class="p">){</span>
                <span class="n">next_largest</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                <span class="n">next_largest_idx</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        
        <span class="n">nums</span><span class="p">[</span><span class="n">next_largest_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">insert_elem</span><span class="p">;</span>
        <span class="n">nums</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">next_largest</span><span class="p">;</span>
        
        <span class="n">reverse</span><span class="p">(</span><span class="n">nums</span><span class="o">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">nums</span><span class="o">.</span><span class="n">end</span><span class="p">());</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>16.Binary Tree Level Order Traversal</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>16.Binary Tree Level Order Traversal</h2>
                <p>Given the root of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).<br> <br>Example 1:<br><br><br>Input: root = [3,9,20,null,null,15,7]<br>Output: [[3],[9,20],[15,7]]<br><br>Example 2:<br><br>Input: root = [1]<br>Output: [[1]]<br><br>Example 3:<br><br>Input: root = []<br>Output: []<br><br> <br>Constraints:<br><br>The number of nodes in the tree is in the range [0, 2000].<br>-1000 <= Node.val <= 1000<br><br></p>
                <a href=https://leetcode.com/problems/binary-tree-level-order-traversal>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="c1"># Definition for a binary tree node.</span>
<span class="c1"># class TreeNode:</span>
<span class="c1">#     def __init__(self, val=0, left=None, right=None):</span>
<span class="c1">#         self.val = val</span>
<span class="c1">#         self.left = left</span>
<span class="c1">#         self.right = right</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">levelOrder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>
        <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">root</span><span class="p">])</span>
        <span class="n">outputs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
            <span class="n">c_level_nodes</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="n">out_level</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">next_queue</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">c_level_nodes</span><span class="p">:</span>
                <span class="n">out_level</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">:</span>
                    <span class="n">next_queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
                    <span class="n">next_queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">next_queue</span><span class="p">):</span>
                <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">next_queue</span><span class="p">)</span>
            <span class="n">outputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">out_level</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">outputs</span>
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>17.Course Schedule II</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>17.Course Schedule II</h2>
                <p>There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.<br><br>For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.<br><br>Return the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array.<br> <br>Example 1:<br><br>Input: numCourses = 2, prerequisites = [[1,0]]<br>Output: [0,1]<br>Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1].<br><br>Example 2:<br><br>Input: numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]<br>Output: [0,2,1,3]<br>Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.<br>So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3].<br><br>Example 3:<br><br>Input: numCourses = 1, prerequisites = []<br>Output: [0]<br><br> <br>Constraints:<br><br>1 <= numCourses <= 2000<br>0 <= prerequisites.length <= numCourses * (numCourses - 1)<br>prerequisites[i].length == 2<br>0 <= ai, bi < numCourses<br>ai != bi<br>All the pairs [ai, bi] are distinct.<br><br></p>
                <a href=https://leetcode.com/problems/course-schedule-ii>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">topo_sort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">adj_list</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">stack</span><span class="p">,</span> <span class="n">visited</span><span class="p">):</span>
        <span class="n">visited</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;G&quot;</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">adj_list</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">visited</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;G&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">is_cyclic</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
                <span class="k">return</span> 
            <span class="k">elif</span> <span class="n">visited</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;W&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">topo_sort</span><span class="p">(</span><span class="n">adj_list</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">stack</span><span class="p">,</span> <span class="n">visited</span><span class="p">)</span>
        
        <span class="n">visited</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;B&quot;</span>
        <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">findOrder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">numCourses</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">prerequisites</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="n">adj_list</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_cyclic</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span> 
        

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numCourses</span><span class="p">):</span>
            <span class="n">adj_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;W&quot;</span>
        
        <span class="k">for</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span> <span class="ow">in</span> <span class="n">prerequisites</span><span class="p">:</span>
            <span class="n">adj_list</span><span class="p">[</span><span class="n">c2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c1</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">c1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numCourses</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">visited</span><span class="p">[</span><span class="n">c1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;W&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">topo_sort</span><span class="p">(</span><span class="n">adj_list</span><span class="p">,</span> <span class="n">c1</span><span class="p">,</span> <span class="n">stack</span><span class="p">,</span> <span class="n">visited</span><span class="p">)</span>
        <span class="n">stack</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span> <span class="o">!=</span> <span class="n">numCourses</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="n">stack</span>
        
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>18.Number of Steps to Reduce a Number in Binary Representation to One</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>18.Number of Steps to Reduce a Number in Binary Representation to One</h2>
                <p>Given the binary representation of an integer as a string s, return the number of steps to reduce it to 1 under the following rules:<br><br><br>If the current number is even, you have to divide it by 2.<br><br><br>If the current number is odd, you have to add 1 to it.<br><br><br>It is guaranteed that you can always reach one for all test cases.<br> <br>Example 1:<br><br>Input: s = "1101"<br>Output: 6<br>Explanation: "1101" corressponds to number 13 in their decimal representation.<br>Step 1) 13 is odd, add 1 and obtain 14. <br>Step 2) 14 is even, divide by 2 and obtain 7.<br>Step 3) 7 is odd, add 1 and obtain 8.<br>Step 4) 8 is even, divide by 2 and obtain 4.  <br>Step 5) 4 is even, divide by 2 and obtain 2. <br>Step 6) 2 is even, divide by 2 and obtain 1.  <br><br>Example 2:<br><br>Input: s = "10"<br>Output: 1<br>Explanation: "10" corresponds to number 2 in their decimal representation.<br>Step 1) 2 is even, divide by 2 and obtain 1.  <br><br>Example 3:<br><br>Input: s = "1"<br>Output: 0<br><br> <br>Constraints:<br><br>1 <= s.length <= 500<br>s consists of characters '0' or '1'<br>s[0] == '1'<br><br></p>
                <a href=https://leetcode.com/problems/number-of-steps-to-reduce-a-number-in-binary-representation-to-one>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="n">public</span><span class="p">:</span>
    <span class="nb">int</span> <span class="n">numSteps</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">unsigned</span> <span class="n">long</span> <span class="n">long</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="nb">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">length</span><span class="p">();</span>
        <span class="nb">int</span> <span class="n">steps</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="nb">int</span> <span class="n">carry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="n">length</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="nb">int</span> <span class="n">bit</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="s1">&#39;0&#39;</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">==</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">carry</span> <span class="o">==</span><span class="mi">0</span> <span class="p">){</span>
                <span class="n">steps</span> <span class="o">+=</span><span class="mi">0</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bit</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">carry</span><span class="o">==</span><span class="mi">1</span><span class="p">){</span>
                <span class="n">steps</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bit</span> <span class="o">==</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">carry</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
                <span class="n">steps</span> <span class="o">+=</span><span class="mi">2</span><span class="p">;</span>
                <span class="n">carry</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">bit</span> <span class="o">==</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">carry</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">steps</span><span class="o">+=</span><span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span><span class="p">{</span>
                <span class="n">steps</span> <span class="o">+=</span><span class="mi">1</span><span class="p">;</span>
                <span class="n">carry</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">std</span><span class="p">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span>  <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot; &quot;</span> <span class="o">&lt;&lt;</span>  <span class="n">bit</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot; &quot;</span><span class="o">&lt;&lt;</span>  <span class="n">steps</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot; &quot;</span><span class="o">&lt;&lt;</span>  <span class="n">carry</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">steps</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>19.Minimum Window Substring</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>19.Minimum Window Substring</h2>
                <p>Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string "".<br>The testcases will be generated such that the answer is unique.<br> <br>Example 1:<br><br>Input: s = "ADOBECODEBANC", t = "ABC"<br>Output: "BANC"<br>Explanation: The minimum window substring "BANC" includes 'A', 'B', and 'C' from string t.<br><br>Example 2:<br><br>Input: s = "a", t = "a"<br>Output: "a"<br>Explanation: The entire string s is the minimum window.<br><br>Example 3:<br><br>Input: s = "a", t = "aa"<br>Output: ""<br>Explanation: Both 'a's from t must be included in the window.<br>Since the largest window of s only has one 'a', return empty string.<br><br> <br>Constraints:<br><br>m == s.length<br>n == t.length<br>1 <= m, n <= 105<br>s and t consist of uppercase and lowercase English letters.<br><br> <br>Follow up: Could you find an algorithm that runs in O(m + n) time?<br></p>
                <a href=https://leetcode.com/problems/minimum-window-substring>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">minWindow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">freq_t</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">freq_s</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">min_substr</span> <span class="o">=</span> <span class="n">s</span><span class="o">+</span><span class="n">t</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">t</span><span class="p">:</span>
            <span class="n">freq_t</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">freq_t</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        
        <span class="k">for</span> <span class="n">end</span><span class="p">,</span> <span class="n">c_e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
            <span class="n">freq_s</span><span class="p">[</span><span class="n">c_e</span><span class="p">]</span> <span class="o">=</span> <span class="n">freq_s</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">c_e</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">valid_substr</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">while</span> <span class="n">valid_substr</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">freq_t</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">freq_t</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">freq_s</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="mi">0</span><span class="p">):</span>
                        <span class="n">valid_substr</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="k">break</span>
                <span class="k">if</span> <span class="n">valid_substr</span><span class="p">:</span>
                    <span class="n">substr</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">min_substr</span> <span class="o">=</span> <span class="n">substr</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">substr</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">min_substr</span><span class="p">)</span> <span class="k">else</span> <span class="n">min_substr</span>
                    <span class="n">freq_s</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">start</span><span class="p">]]</span> <span class="o">-=</span> <span class="mi">1</span>
                    <span class="n">start</span><span class="o">+=</span><span class="mi">1</span> 
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">min_substr</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">):</span> <span class="k">return</span> <span class="s2">&quot;&quot;</span>
        <span class="k">return</span> <span class="n">min_substr</span>
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>20.Course Schedule</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>20.Course Schedule</h2>
                <p>There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.<br><br>For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.<br><br>Return true if you can finish all courses. Otherwise, return false.<br> <br>Example 1:<br><br>Input: numCourses = 2, prerequisites = [[1,0]]<br>Output: true<br>Explanation: There are a total of 2 courses to take. <br>To take course 1 you should have finished course 0. So it is possible.<br><br>Example 2:<br><br>Input: numCourses = 2, prerequisites = [[1,0],[0,1]]<br>Output: false<br>Explanation: There are a total of 2 courses to take. <br>To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.<br><br> <br>Constraints:<br><br>1 <= numCourses <= 2000<br>0 <= prerequisites.length <= 5000<br>prerequisites[i].length == 2<br>0 <= ai, bi < numCourses<br>All the pairs prerequisites[i] are unique.<br><br></p>
                <a href=https://leetcode.com/problems/course-schedule>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">canFinish</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">numCourses</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">prerequisites</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        4 -&gt; 1 -&gt; 3</span>
<span class="sd">        4 -&gt; 2 -&gt; 3</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">check_cycle</span><span class="p">(</span><span class="n">adj_list</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">visited</span><span class="p">):</span>
            <span class="n">visited</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;G&quot;</span>

            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">adj_list</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
                <span class="n">is_cyclic</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="n">visited</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;G&quot;</span><span class="p">:</span>
                    <span class="n">is_cyclic</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">elif</span> <span class="n">visited</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;W&quot;</span><span class="p">:</span>
                    <span class="n">is_cyclic</span> <span class="o">=</span> <span class="n">check_cycle</span><span class="p">(</span><span class="n">adj_list</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">visited</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">is_cyclic</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">True</span>
            <span class="n">visited</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;B&quot;</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">adj_list</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">course</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numCourses</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">adj_list</span><span class="p">[</span><span class="n">course</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">visited</span><span class="p">[</span><span class="n">course</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;W&quot;</span>
        
        <span class="k">for</span> <span class="n">course1</span><span class="p">,</span> <span class="n">course2</span> <span class="ow">in</span> <span class="n">prerequisites</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">adj_list</span><span class="p">[</span><span class="n">course1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">course2</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numCourses</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">visited</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;W&quot;</span><span class="p">:</span>
                <span class="n">is_cyclic</span> <span class="o">=</span> <span class="n">check_cycle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">adj_list</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">visited</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">is_cyclic</span> <span class="p">:</span> <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>21.Decode Ways</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>21.Decode Ways</h2>
                <p>A message containing letters from A-Z can be encoded into numbers using the following mapping:<br><br>'A' -> "1"<br>'B' -> "2"<br>...<br>'Z' -> "26"<br><br>To decode an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, "11106" can be mapped into:<br><br>"AAJF" with the grouping (1 1 10 6)<br>"KJF" with the grouping (11 10 6)<br><br>Note that the grouping (1 11 06) is invalid because "06" cannot be mapped into 'F' since "6" is different from "06".<br>Given a string s containing only digits, return the number of ways to decode it.<br>The test cases are generated so that the answer fits in a 32-bit integer.<br> <br>Example 1:<br><br>Input: s = "12"<br>Output: 2<br>Explanation: "12" could be decoded as "AB" (1 2) or "L" (12).<br><br>Example 2:<br><br>Input: s = "226"<br>Output: 3<br>Explanation: "226" could be decoded as "BZ" (2 26), "VF" (22 6), or "BBF" (2 2 6).<br><br>Example 3:<br><br>Input: s = "06"<br>Output: 0<br>Explanation: "06" cannot be mapped to "F" because of the leading zero ("6" is different from "06").<br><br> <br>Constraints:<br><br>1 <= s.length <= 100<br>s contains only digits and may contain leading zero(s).<br><br></p>
                <a href=https://leetcode.com/problems/decode-ways>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">numDecodings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">memo</span> <span class="o">=</span> <span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">},</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;0&quot;</span><span class="p">:</span><span class="k">return</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">k</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="p">:</span><span class="k">return</span> <span class="n">memo</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">memo</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">!=</span><span class="s2">&quot;0&quot;</span><span class="p">:</span>
            <span class="n">memo</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="n">memo</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="mi">10</span> <span class="o">&lt;=</span> <span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="mi">26</span> <span class="ow">and</span> <span class="n">s</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">!=</span><span class="s2">&quot;0&quot;</span><span class="p">:</span>
            <span class="n">memo</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="n">memo</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">numDecodings</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">memo</span><span class="p">,</span> <span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">memo</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>22.Pacific Atlantic Water Flow</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>22.Pacific Atlantic Water Flow</h2>
                <p>There is an m x n rectangular island that borders both the Pacific Ocean and Atlantic Ocean. The Pacific Ocean touches the island's left and top edges, and the Atlantic Ocean touches the island's right and bottom edges.<br>The island is partitioned into a grid of square cells. You are given an m x n integer matrix heights where heights[r][c] represents the height above sea level of the cell at coordinate (r, c).<br>The island receives a lot of rain, and the rain water can flow to neighboring cells directly north, south, east, and west if the neighboring cell's height is less than or equal to the current cell's height. Water can flow from any cell adjacent to an ocean into the ocean.<br>Return a 2D list of grid coordinates result where result[i] = [ri, ci] denotes that rain water can flow from cell (ri, ci) to both the Pacific and Atlantic oceans.<br> <br>Example 1:<br><br><br>Input: heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]<br>Output: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]<br>Explanation: The following cells can flow to the Pacific and Atlantic oceans, as shown below:<br>[0,4]: [0,4] -> Pacific Ocean <br>       [0,4] -> Atlantic Ocean<br>[1,3]: [1,3] -> [0,3] -> Pacific Ocean <br>       [1,3] -> [1,4] -> Atlantic Ocean<br>[1,4]: [1,4] -> [1,3] -> [0,3] -> Pacific Ocean <br>       [1,4] -> Atlantic Ocean<br>[2,2]: [2,2] -> [1,2] -> [0,2] -> Pacific Ocean <br>       [2,2] -> [2,3] -> [2,4] -> Atlantic Ocean<br>[3,0]: [3,0] -> Pacific Ocean <br>       [3,0] -> [4,0] -> Atlantic Ocean<br>[3,1]: [3,1] -> [3,0] -> Pacific Ocean <br>       [3,1] -> [4,1] -> Atlantic Ocean<br>[4,0]: [4,0] -> Pacific Ocean <br>       [4,0] -> Atlantic Ocean<br>Note that there are other possible paths for these cells to flow to the Pacific and Atlantic oceans.<br><br>Example 2:<br><br>Input: heights = [[1]]<br>Output: [[0,0]]<br>Explanation: The water can flow from the only cell to the Pacific and Atlantic oceans.<br><br> <br>Constraints:<br><br>m == heights.length<br>n == heights[r].length<br>1 <= m, n <= 200<br>0 <= heights[r][c] <= 105<br><br></p>
                <a href=https://leetcode.com/problems/pacific-atlantic-water-flow>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">pacificAtlantic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">heights</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>

        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">heights</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">ROWS</span><span class="p">,</span> <span class="n">COLS</span><span class="p">):</span>
            <span class="n">r</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">pos</span>
            <span class="k">if</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                <span class="k">return</span> 
            
            <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">dr</span><span class="p">,</span> <span class="n">dc</span> <span class="ow">in</span> <span class="p">[</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]:</span>
                <span class="n">r1</span><span class="p">,</span> <span class="n">c1</span> <span class="o">=</span> <span class="n">r</span><span class="o">+</span><span class="n">dr</span><span class="p">,</span> <span class="n">c</span><span class="o">+</span><span class="n">dc</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">r1</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">r1</span> <span class="o">&gt;=</span> <span class="n">ROWS</span> <span class="ow">or</span> <span class="n">c1</span><span class="o">&lt;</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">c1</span><span class="o">&gt;=</span><span class="n">COLS</span><span class="p">)</span> <span class="ow">and</span> <span class="n">heights</span><span class="p">[</span><span class="n">r1</span><span class="p">][</span><span class="n">c1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">heights</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]:</span>
                    <span class="n">dfs</span><span class="p">((</span><span class="n">r1</span><span class="p">,</span><span class="n">c1</span><span class="p">),</span> <span class="n">heights</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">ROWS</span><span class="p">,</span> <span class="n">COLS</span><span class="p">)</span>

        <span class="n">pac_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">atl_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">ROWS</span><span class="p">,</span> <span class="n">COLS</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">heights</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">heights</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ROWS</span><span class="p">):</span>
            <span class="n">pos_pac</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">pos_pac</span><span class="p">,</span> <span class="n">heights</span><span class="p">,</span> <span class="n">pac_set</span><span class="p">,</span> <span class="n">ROWS</span><span class="p">,</span> <span class="n">COLS</span><span class="p">)</span>

            <span class="n">pos_atl</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">COLS</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">pos_atl</span><span class="p">,</span> <span class="n">heights</span><span class="p">,</span> <span class="n">atl_set</span><span class="p">,</span> <span class="n">ROWS</span><span class="p">,</span> <span class="n">COLS</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">COLS</span><span class="p">):</span>
            <span class="n">pos_pac</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">pos_pac</span><span class="p">,</span> <span class="n">heights</span><span class="p">,</span> <span class="n">pac_set</span><span class="p">,</span> <span class="n">ROWS</span><span class="p">,</span> <span class="n">COLS</span><span class="p">)</span>

            <span class="n">pos_atl</span> <span class="o">=</span> <span class="p">(</span><span class="n">ROWS</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">pos_atl</span><span class="p">,</span> <span class="n">heights</span><span class="p">,</span> <span class="n">atl_set</span><span class="p">,</span> <span class="n">ROWS</span><span class="p">,</span> <span class="n">COLS</span><span class="p">)</span>

        <span class="n">out_set</span> <span class="o">=</span> <span class="n">pac_set</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">atl_set</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out_set</span>
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>23.Climbing Stairs</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>23.Climbing Stairs</h2>
                <p>You are climbing a staircase. It takes n steps to reach the top.<br>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?<br> <br>Example 1:<br><br>Input: n = 2<br>Output: 2<br>Explanation: There are two ways to climb to the top.<br>1. 1 step + 1 step<br>2. 2 steps<br><br>Example 2:<br><br>Input: n = 3<br>Output: 3<br>Explanation: There are three ways to climb to the top.<br>1. 1 step + 1 step + 1 step<br>2. 1 step + 2 steps<br>3. 2 steps + 1 step<br><br> <br>Constraints:<br><br>1 <= n <= 45<br><br></p>
                <a href=https://leetcode.com/problems/climbing-stairs>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">climbStairs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span><span class="k">return</span> <span class="n">n</span>
        <span class="n">prev1</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="n">prev2</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">current</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">prev1</span> <span class="o">+</span> <span class="n">prev2</span> 
            <span class="n">prev2</span> <span class="o">=</span> <span class="n">prev1</span>
            <span class="n">prev1</span> <span class="o">=</span> <span class="n">current</span> 
        <span class="k">return</span> <span class="n">current</span>
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>24.Word Break</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>24.Word Break</h2>
                <p>Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words.<br>Note that the same word in the dictionary may be reused multiple times in the segmentation.<br> <br>Example 1:<br><br>Input: s = "leetcode", wordDict = ["leet","code"]<br>Output: true<br>Explanation: Return true because "leetcode" can be segmented as "leet code".<br><br>Example 2:<br><br>Input: s = "applepenapple", wordDict = ["apple","pen"]<br>Output: true<br>Explanation: Return true because "applepenapple" can be segmented as "apple pen apple".<br>Note that you are allowed to reuse a dictionary word.<br><br>Example 3:<br><br>Input: s = "catsandog", wordDict = ["cats","dog","sand","and","cat"]<br>Output: false<br><br> <br>Constraints:<br><br>1 <= s.length <= 300<br>1 <= wordDict.length <= 1000<br>1 <= wordDict[i].length <= 20<br>s and wordDict[i] consist of only lowercase English letters.<br>All the strings of wordDict are unique.<br><br></p>
                <a href=https://leetcode.com/problems/word-break>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">memo</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">def</span> <span class="nf">wordBreak</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">wordDict</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">memo</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">memo</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)]</span>
        <span class="n">status</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">wordDict</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">s</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">word</span><span class="p">)]</span> <span class="o">==</span> <span class="n">word</span><span class="p">:</span>
                <span class="n">status</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wordBreak</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">word</span><span class="p">):],</span> <span class="n">wordDict</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">memo</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)]</span> <span class="o">=</span> <span class="n">status</span>
                <span class="k">if</span> <span class="n">status</span><span class="p">:</span> <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">status</span>
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>25.Validate Binary Search Tree</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>25.Validate Binary Search Tree</h2>
                <p>Given the root of a binary tree, determine if it is a valid binary search tree (BST).<br>A valid BST is defined as follows:<br><br>The left subtree of a node contains only nodes with keys less than the node's key.<br>The right subtree of a node contains only nodes with keys greater than the node's key.<br>Both the left and right subtrees must also be binary search trees.<br><br> <br>Example 1:<br><br><br>Input: root = [2,1,3]<br>Output: true<br><br>Example 2:<br><br><br>Input: root = [5,1,4,null,null,3,6]<br>Output: false<br>Explanation: The root node's value is 5 but its right child's value is 4.<br><br> <br>Constraints:<br><br>The number of nodes in the tree is in the range [1, 104].<br>-231 <= Node.val <= 231 - 1<br><br></p>
                <a href=https://leetcode.com/problems/validate-binary-search-tree>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="c1"># Definition for a binary tree node.</span>
<span class="c1"># class TreeNode:</span>
<span class="c1">#     def __init__(self, val=0, left=None, right=None):</span>
<span class="c1">#         self.val = val</span>
<span class="c1">#         self.left = left</span>
<span class="c1">#         self.right = right</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">isValidBST</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">limits</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="s2">&quot;-inf&quot;</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">limits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span><span class="n">root</span><span class="o">.</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">limits</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">return</span> <span class="kc">False</span>
        
        <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">isValidBST</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">,</span>  <span class="p">(</span><span class="n">limits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">root</span><span class="o">.</span><span class="n">val</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">left</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span><span class="k">return</span> <span class="kc">False</span>
        <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">isValidBST</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">val</span><span class="p">,</span> <span class="n">limits</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

        <span class="k">return</span> <span class="n">left</span> <span class="ow">and</span> <span class="n">right</span>
        
        
        
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>26.Insert Interval</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>26.Insert Interval</h2>
                <p>You are given an array of non-overlapping intervals intervals where intervals[i] = [starti, endi] represent the start and the end of the ith interval and intervals is sorted in ascending order by starti. You are also given an interval newInterval = [start, end] that represents the start and end of another interval.<br>Insert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary).<br>Return intervals after the insertion.<br>Note that you don't need to modify intervals in-place. You can make a new array and return it.<br> <br>Example 1:<br><br>Input: intervals = [[1,3],[6,9]], newInterval = [2,5]<br>Output: [[1,5],[6,9]]<br><br>Example 2:<br><br>Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]<br>Output: [[1,2],[3,10],[12,16]]<br>Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].<br><br> <br>Constraints:<br><br>0 <= intervals.length <= 104<br>intervals[i].length == 2<br>0 <= starti <= endi <= 105<br>intervals is sorted by starti in ascending order.<br>newInterval.length == 2<br>0 <= start <= end <= 105<br><br></p>
                <a href=https://leetcode.com/problems/insert-interval>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">intervals</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="n">newInterval</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">intervals</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">newInterval</span><span class="p">]</span>

        <span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ns</span><span class="p">,</span> <span class="n">ne</span> <span class="o">=</span> <span class="n">newInterval</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">intervals</span><span class="p">)):</span>
            <span class="n">cs</span><span class="p">,</span> <span class="n">ce</span> <span class="o">=</span> <span class="n">intervals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">ns</span> <span class="o">&lt;</span> <span class="n">cs</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">intervals</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">output</span><span class="p">):</span>
            <span class="n">cs</span><span class="p">,</span> <span class="n">ce</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">ns</span> <span class="o">&lt;=</span> <span class="n">ce</span><span class="p">:</span>
                <span class="c1"># overlap</span>
                <span class="n">cs</span><span class="p">,</span> <span class="n">ce</span> <span class="o">=</span> <span class="n">cs</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">ce</span><span class="p">,</span> <span class="n">ne</span><span class="p">)</span>
                <span class="n">output</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">cs</span><span class="p">,</span> <span class="n">ce</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newInterval</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newInterval</span><span class="p">)</span>
        <span class="nb">print</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">intervals</span><span class="p">)):</span>
            <span class="n">cs</span><span class="p">,</span> <span class="n">ce</span> <span class="o">=</span> <span class="n">intervals</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="n">ps</span><span class="p">,</span> <span class="n">pe</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">cs</span> <span class="o">&lt;=</span> <span class="n">pe</span><span class="p">:</span>
                <span class="n">output</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ps</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">ce</span><span class="p">,</span> <span class="n">pe</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">cs</span><span class="p">,</span><span class="n">ce</span><span class="p">])</span>
        
        <span class="k">return</span> <span class="n">output</span>
            
                



            
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>27.Unique Paths</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>27.Unique Paths</h2>
                <p>There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.<br>Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.<br>The test cases are generated so that the answer will be less than or equal to 2 * 109.<br> <br>Example 1:<br><br><br>Input: m = 3, n = 7<br>Output: 28<br><br>Example 2:<br><br>Input: m = 3, n = 2<br>Output: 3<br>Explanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:<br>1. Right -> Down -> Down<br>2. Down -> Down -> Right<br>3. Down -> Right -> Down<br><br> <br>Constraints:<br><br>1 <= m, n <= 100<br><br></p>
                <a href=https://leetcode.com/problems/unique-paths>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">uniquePaths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">paths_mat</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">)]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">m</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
                <span class="n">top</span> <span class="o">=</span> <span class="n">paths_mat</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> 
                <span class="n">left</span> <span class="o">=</span> <span class="n">paths_mat</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">paths_mat</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="n">top</span>
        <span class="k">return</span> <span class="n">paths_mat</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>28.Find Median from Data Stream</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>28.Find Median from Data Stream</h2>
                <p>The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value, and the median is the mean of the two middle values.<br><br>For example, for arr = [2,3,4], the median is 3.<br>For example, for arr = [2,3], the median is (2 + 3) / 2 = 2.5.<br><br>Implement the MedianFinder class:<br><br>MedianFinder() initializes the MedianFinder object.<br>void addNum(int num) adds the integer num from the data stream to the data structure.<br>double findMedian() returns the median of all elements so far. Answers within 10-5 of the actual answer will be accepted.<br><br> <br>Example 1:<br><br>Input<br>["MedianFinder", "addNum", "addNum", "findMedian", "addNum", "findMedian"]<br>[[], [1], [2], [], [3], []]<br>Output<br>[null, null, null, 1.5, null, 2.0]<br><br>Explanation<br>MedianFinder medianFinder = new MedianFinder();<br>medianFinder.addNum(1);    // arr = [1]<br>medianFinder.addNum(2);    // arr = [1, 2]<br>medianFinder.findMedian(); // return 1.5 (i.e., (1 + 2) / 2)<br>medianFinder.addNum(3);    // arr[1, 2, 3]<br>medianFinder.findMedian(); // return 2.0<br><br> <br>Constraints:<br><br>-105 <= num <= 105<br>There will be at least one element in the data structure before calling findMedian.<br>At most 5 * 104 calls will be made to addNum and findMedian.<br><br> <br>Follow up:<br><br>If all integer numbers from the stream are in the range [0, 100], how would you optimize your solution?<br>If 99% of all integer numbers from the stream are in the range [0, 100], how would you optimize your solution?<br><br></p>
                <a href=https://leetcode.com/problems/find-median-from-data-stream>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">heapq</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd"> 1 2 3</span>
<span class="sd"> l  1. 3</span>
<span class="sd"> r  2</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="k">class</span> <span class="nc">MedianFinder</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left_data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right_data</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">addNum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left_data</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">right_data</span><span class="p">):</span>
            <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left_data</span><span class="p">,</span> <span class="o">-</span><span class="n">num</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">right_data</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left_data</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">right_data</span><span class="p">)</span> <span class="p">:</span>
            <span class="k">if</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">left_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">right_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">left_max</span> <span class="o">=</span> <span class="o">-</span><span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left_data</span><span class="p">)</span>
                <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">right_data</span><span class="p">,</span> <span class="n">left_max</span><span class="p">)</span>

                <span class="n">right_min</span> <span class="o">=</span> <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">right_data</span><span class="p">)</span>
                <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left_data</span><span class="p">,</span> <span class="o">-</span><span class="n">right_min</span><span class="p">)</span>
        <span class="c1">#print(num, self.left_data, self.right_data)</span>
            
    <span class="k">def</span> <span class="nf">findMedian</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="n">median</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left_data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">right_data</span><span class="p">):</span>
            <span class="n">median</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">left_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">median</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">left_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">right_data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span>
        <span class="k">return</span> <span class="n">median</span>
        


<span class="c1"># Your MedianFinder object will be instantiated and called as such:</span>
<span class="c1"># obj = MedianFinder()</span>
<span class="c1"># obj.addNum(num)</span>
<span class="c1"># param_2 = obj.findMedian()</span>
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>29.Flatten Binary Tree to Linked List</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>29.Flatten Binary Tree to Linked List</h2>
                <p>Given the root of a binary tree, flatten the tree into a "linked list":<br><br>The "linked list" should use the same TreeNode class where the right child pointer points to the next node in the list and the left child pointer is always null.<br>The "linked list" should be in the same order as a pre-order traversal of the binary tree.<br><br> <br>Example 1:<br><br><br>Input: root = [1,2,5,3,4,null,6]<br>Output: [1,null,2,null,3,null,4,null,5,null,6]<br><br>Example 2:<br><br>Input: root = []<br>Output: []<br><br>Example 3:<br><br>Input: root = [0]<br>Output: [0]<br><br> <br>Constraints:<br><br>The number of nodes in the tree is in the range [0, 2000].<br>-100 <= Node.val <= 100<br><br> <br>Follow up: Can you flatten the tree in-place (with O(1) extra space)?</p>
                <a href=https://leetcode.com/problems/flatten-binary-tree-to-linked-list>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="c1"># Definition for a binary tree node.</span>
<span class="c1"># class TreeNode:</span>
<span class="c1">#     def __init__(self, val=0, left=None, right=None):</span>
<span class="c1">#         self.val = val</span>
<span class="c1">#         self.left = left</span>
<span class="c1">#         self.right = right</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">     1</span>
<span class="sd">        2   </span>
<span class="sd">            3</span>
<span class="sd">                None</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">_flatten</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">left_node</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">left</span>
        <span class="n">right_node</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">right</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">left_node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">right_node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">root</span>

        <span class="n">left_tail</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flatten</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
        <span class="n">right_tail</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flatten</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">)</span> 

        <span class="k">if</span> <span class="n">left_tail</span><span class="p">:</span>
            <span class="n">left_tail</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right_node</span>
            <span class="n">root</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">left_node</span>
            <span class="n">root</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="kc">None</span> 
        
        <span class="k">if</span> <span class="n">right_tail</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">right_tail</span>
        <span class="k">return</span> <span class="n">left_tail</span>

    <span class="k">def</span> <span class="nf">flatten</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Do not return anything, modify root in-place instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_flatten</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>30.Top K Frequent Elements</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>30.Top K Frequent Elements</h2>
                <p>Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.<br> <br>Example 1:<br>Input: nums = [1,1,1,2,2,3], k = 2<br>Output: [1,2]<br>Example 2:<br>Input: nums = [1], k = 1<br>Output: [1]<br><br> <br>Constraints:<br><br>1 <= nums.length <= 105<br>-104 <= nums[i] <= 104<br>k is in the range [1, the number of unique elements in the array].<br>It is guaranteed that the answer is unique.<br><br> <br>Follow up: Your algorithm's time complexity must be better than O(n log n), where n is the array's size.<br></p>
                <a href=https://leetcode.com/problems/top-k-frequent-elements>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">heapq</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">topKFrequent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="n">min_heap</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">freq_count</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
            <span class="n">freq_count</span><span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="o">=</span> <span class="n">freq_count</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        
        <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">freq_count</span><span class="p">:</span>
            <span class="n">freq</span> <span class="o">=</span> <span class="n">freq_count</span><span class="p">[</span><span class="n">num</span><span class="p">]</span>
            <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span> <span class="n">min_heap</span><span class="p">,</span> <span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">num</span><span class="p">))</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">min_heap</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">k</span><span class="p">:</span>
                <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">min_heap</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="p">[</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">min_heap</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">output</span>
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>31.Best Time to Buy and Sell Stock</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>31.Best Time to Buy and Sell Stock</h2>
                <p>You are given an array prices where prices[i] is the price of a given stock on the ith day.<br>You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.<br>Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.<br> <br>Example 1:<br><br>Input: prices = [7,1,5,3,6,4]<br>Output: 5<br>Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.<br>Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.<br><br>Example 2:<br><br>Input: prices = [7,6,4,3,1]<br>Output: 0<br>Explanation: In this case, no transactions are done and the max profit = 0.<br><br> <br>Constraints:<br><br>1 <= prices.length <= 105<br>0 <= prices[i] <= 104<br><br></p>
                <a href=https://leetcode.com/problems/best-time-to-buy-and-sell-stock>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">maxProfit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">minm</span> <span class="o">=</span> <span class="n">prices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">profit</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">price</span> <span class="ow">in</span> <span class="n">prices</span><span class="p">:</span>
            <span class="n">profit</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">profit</span><span class="p">,</span> <span class="n">price</span><span class="o">-</span><span class="n">minm</span><span class="p">)</span>
            <span class="n">minm</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">minm</span><span class="p">,</span> <span class="n">price</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">profit</span>
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>32.Merge k Sorted Lists</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>32.Merge k Sorted Lists</h2>
                <p>You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.<br>Merge all the linked-lists into one sorted linked-list and return it.<br> <br>Example 1:<br><br>Input: lists = [[1,4,5],[1,3,4],[2,6]]<br>Output: [1,1,2,3,4,4,5,6]<br>Explanation: The linked-lists are:<br>[<br>  1->4->5,<br>  1->3->4,<br>  2->6<br>]<br>merging them into one sorted list:<br>1->1->2->3->4->4->5->6<br><br>Example 2:<br><br>Input: lists = []<br>Output: []<br><br>Example 3:<br><br>Input: lists = [[]]<br>Output: []<br><br> <br>Constraints:<br><br>k == lists.length<br>0 <= k <= 104<br>0 <= lists[i].length <= 500<br>-104 <= lists[i][j] <= 104<br>lists[i] is sorted in ascending order.<br>The sum of lists[i].length will not exceed 104.<br><br></p>
                <a href=https://leetcode.com/problems/merge-k-sorted-lists>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="c1"># Definition for singly-linked list.</span>
<span class="c1"># class ListNode:</span>
<span class="c1">#     def __init__(self, val=0, next=None):</span>
<span class="c1">#         self.val = val</span>
<span class="c1">#         self.next = next</span>

<span class="kn">import</span> <span class="nn">heapq</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">mergeKLists</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lists</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">]:</span>
        <span class="n">merged_list</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">min_heap</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">head</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lists</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">head</span><span class="p">:</span>
                <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">min_heap</span><span class="p">,</span> <span class="p">(</span><span class="n">head</span><span class="o">.</span><span class="n">val</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">head</span><span class="p">))</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">merged_list</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">()</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">merged_list</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">min_heap</span><span class="p">):</span>
            <span class="n">val</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">min_node</span> <span class="o">=</span> <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">min_heap</span><span class="p">)</span>
            <span class="n">merged_list</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">min_node</span>

            <span class="n">min_node</span> <span class="o">=</span> <span class="n">min_node</span><span class="o">.</span><span class="n">next</span>
            <span class="n">merged_list</span> <span class="o">=</span> <span class="n">merged_list</span><span class="o">.</span><span class="n">next</span>
            
            <span class="k">if</span> <span class="n">min_node</span><span class="p">:</span>
                <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">min_heap</span><span class="p">,</span> <span class="p">(</span><span class="n">min_node</span><span class="o">.</span><span class="n">val</span><span class="p">,</span> <span class="n">idx</span> <span class="p">,</span> <span class="n">min_node</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">next</span>
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>33.Palindromic Substrings</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>33.Palindromic Substrings</h2>
                <p>Given a string s, return the number of palindromic substrings in it.<br>A string is a palindrome when it reads the same backward as forward.<br>A substring is a contiguous sequence of characters within the string.<br> <br>Example 1:<br><br>Input: s = "abc"<br>Output: 3<br>Explanation: Three palindromic strings: "a", "b", "c".<br><br>Example 2:<br><br>Input: s = "aaa"<br>Output: 6<br>Explanation: Six palindromic strings: "a", "a", "a", "aa", "aa", "aaa".<br><br> <br>Constraints:<br><br>1 <= s.length <= 1000<br>s consists of lowercase English letters.<br><br></p>
                <a href=https://leetcode.com/problems/palindromic-substrings>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">countSubstrings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">dp</span> <span class="o">=</span> <span class="p">[[</span> <span class="kc">False</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">))]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">))]</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)):</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">count</span> <span class="o">+=</span><span class="mi">1</span>
        
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">-</span><span class="n">k</span><span class="p">):</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="n">k</span>
                <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                
                <span class="k">if</span> <span class="n">k</span><span class="o">==</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">left</span><span class="o">==</span><span class="n">right</span><span class="p">:</span>
                    <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">count</span> <span class="o">+=</span><span class="mi">1</span>
                <span class="k">elif</span> <span class="n">left</span> <span class="o">==</span> <span class="n">right</span> <span class="ow">and</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">count</span> <span class="o">+=</span><span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">count</span>
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>34.String to Integer (atoi)</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>34.String to Integer (atoi)</h2>
                <p>Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer.<br>The algorithm for myAtoi(string s) is as follows:<br><br>Whitespace: Ignore any leading whitespace (" ").<br>Signedness: Determine the sign by checking if the next character is '-' or '+', assuming positivity is neither present.<br>Conversion: Read the integer by skipping leading zeros until a non-digit character is encountered or the end of the string is reached. If no digits were read, then the result is 0.<br>Rounding: If the integer is out of the 32-bit signed integer range [-231, 231 - 1], then round the integer to remain in the range. Specifically, integers less than -231 should be rounded to -231, and integers greater than 231 - 1 should be rounded to 231 - 1.<br><br>Return the integer as the final result.<br> <br>Example 1:<br><br>Input: s = "42"<br>Output: 42<br>Explanation:<br><br>The underlined characters are what is read in and the caret is the current reader position.<br>Step 1: "42" (no characters read because there is no leading whitespace)<br>         ^<br>Step 2: "42" (no characters read because there is neither a '-' nor '+')<br>         ^<br>Step 3: "42" ("42" is read in)<br>           ^<br><br><br>Example 2:<br><br>Input: s = " -042"<br>Output: -42<br>Explanation:<br><br>Step 1: "   -042" (leading whitespace is read and ignored)<br>            ^<br>Step 2: "   -042" ('-' is read, so the result should be negative)<br>             ^<br>Step 3: "   -042" ("042" is read in, leading zeros ignored in the result)<br>               ^<br><br><br>Example 3:<br><br>Input: s = "1337c0d3"<br>Output: 1337<br>Explanation:<br><br>Step 1: "1337c0d3" (no characters read because there is no leading whitespace)<br>         ^<br>Step 2: "1337c0d3" (no characters read because there is neither a '-' nor '+')<br>         ^<br>Step 3: "1337c0d3" ("1337" is read in; reading stops because the next character is a non-digit)<br>             ^<br><br><br>Example 4:<br><br>Input: s = "0-1"<br>Output: 0<br>Explanation:<br><br>Step 1: "0-1" (no characters read because there is no leading whitespace)<br>         ^<br>Step 2: "0-1" (no characters read because there is neither a '-' nor '+')<br>         ^<br>Step 3: "0-1" ("0" is read in; reading stops because the next character is a non-digit)<br>          ^<br><br><br>Example 5:<br><br>Input: s = "words and 987"<br>Output: 0<br>Explanation:<br>Reading stops at the first non-digit character 'w'.<br><br> <br>Constraints:<br><br>0 <= s.length <= 200<br>s consists of English letters (lower-case and upper-case), digits (0-9), ' ', '+', '-', and '.'.<br><br></p>
                <a href=https://leetcode.com/problems/string-to-integer-atoi>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">myAtoi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">string</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">string</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span><span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">sign</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">string</span><span class="p">)):</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">string</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">c</span><span class="o">==</span><span class="s2">&quot; &quot;</span><span class="p">:</span><span class="k">continue</span>
            <span class="k">elif</span> <span class="n">c</span><span class="o">==</span><span class="s2">&quot;-&quot;</span><span class="p">:</span>
                <span class="n">sign</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="n">i</span> <span class="o">+=</span><span class="mi">1</span>
                <span class="k">break</span>
            <span class="k">elif</span> <span class="n">c</span><span class="o">==</span><span class="s2">&quot;+&quot;</span><span class="p">:</span>
                <span class="n">i</span><span class="o">+=</span><span class="mi">1</span>
                <span class="k">break</span>
                
            <span class="k">elif</span> <span class="s1">&#39;0&#39;</span><span class="o">&lt;=</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="s1">&#39;9&#39;</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        
        <span class="n">num_str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span> 
        
        <span class="k">while</span> <span class="n">i</span><span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">string</span><span class="p">)</span> <span class="ow">and</span> <span class="s1">&#39;0&#39;</span><span class="o">&lt;=</span><span class="n">string</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;=</span><span class="s1">&#39;9&#39;</span><span class="p">:</span>
            <span class="n">num</span> <span class="o">=</span> <span class="n">num</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">string</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">i</span><span class="o">+=</span> <span class="mi">1</span>
        
        <span class="n">num</span> <span class="o">=</span> <span class="n">sign</span> <span class="o">*</span> <span class="n">num</span>    
        <span class="n">minm</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">31</span><span class="p">)</span>
        <span class="n">maxm</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">31</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">num</span> <span class="o">&lt;</span> <span class="o">-</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">31</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">minm</span>
        <span class="k">if</span> <span class="n">num</span> <span class="o">&gt;</span> <span class="n">maxm</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">maxm</span>
        <span class="k">return</span> <span class="n">num</span>
        
        
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>35.Binary Tree Maximum Path Sum</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>35.Binary Tree Maximum Path Sum</h2>
                <p>A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root.<br>The path sum of a path is the sum of the node's values in the path.<br>Given the root of a binary tree, return the maximum path sum of any non-empty path.<br> <br>Example 1:<br><br><br>Input: root = [1,2,3]<br>Output: 6<br>Explanation: The optimal path is 2 -> 1 -> 3 with a path sum of 2 + 1 + 3 = 6.<br><br>Example 2:<br><br><br>Input: root = [-10,9,20,null,null,15,7]<br>Output: 42<br>Explanation: The optimal path is 15 -> 20 -> 7 with a path sum of 15 + 20 + 7 = 42.<br><br> <br>Constraints:<br><br>The number of nodes in the tree is in the range [1, 3 * 104].<br>-1000 <= Node.val <= 1000<br><br></p>
                <a href=https://leetcode.com/problems/binary-tree-maximum-path-sum>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="c1"># Definition for a binary tree node.</span>
<span class="c1"># class TreeNode:</span>
<span class="c1">#     def __init__(self, val=0, left=None, right=None):</span>
<span class="c1">#         self.val = val</span>
<span class="c1">#         self.left = left</span>
<span class="c1">#         self.right = right</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">_pathSum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        
        <span class="n">left_sum</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pathSum</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
        <span class="n">right_sum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pathSum</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>

        <span class="n">c_node_path_sum</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">left_sum</span><span class="p">,</span> <span class="n">right_sum</span><span class="p">,</span> <span class="n">left_sum</span><span class="o">+</span><span class="n">right_sum</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">root</span><span class="o">.</span><span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_path_sum</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">c_node_path_sum</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_path_sum</span><span class="p">)</span>

        <span class="n">max_path_sum</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">left_sum</span><span class="p">,</span> <span class="n">right_sum</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">root</span><span class="o">.</span><span class="n">val</span>
        <span class="k">return</span> <span class="n">max_path_sum</span>

    <span class="k">def</span> <span class="nf">maxPathSum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_path_sum</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;-inf&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pathSum</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_path_sum</span>
        
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>36.Valid Palindrome</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>36.Valid Palindrome</h2>
                <p>A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.<br>Given a string s, return true if it is a palindrome, or false otherwise.<br> <br>Example 1:<br><br>Input: s = "A man, a plan, a canal: Panama"<br>Output: true<br>Explanation: "amanaplanacanalpanama" is a palindrome.<br><br>Example 2:<br><br>Input: s = "race a car"<br>Output: false<br>Explanation: "raceacar" is not a palindrome.<br><br>Example 3:<br><br>Input: s = " "<br>Output: true<br>Explanation: s is an empty string "" after removing non-alphanumeric characters.<br>Since an empty string reads the same forward and backward, it is a palindrome.<br><br> <br>Constraints:<br><br>1 <= s.length <= 2 * 105<br>s consists only of printable ASCII characters.<br><br></p>
                <a href=https://leetcode.com/problems/valid-palindrome>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">isPalindrome</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">r</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>

        <span class="k">while</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">s</span><span class="p">[</span><span class="n">l</span><span class="p">]</span><span class="o">.</span><span class="n">isalnum</span><span class="p">():</span>
                <span class="n">l</span><span class="o">+=</span><span class="mi">1</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">s</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">.</span><span class="n">isalnum</span><span class="p">():</span>
                <span class="n">r</span><span class="o">-=</span><span class="mi">1</span>
            <span class="k">elif</span> <span class="n">s</span><span class="p">[</span><span class="n">l</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>
                <span class="n">l</span><span class="o">+=</span><span class="mi">1</span>
                <span class="n">r</span><span class="o">-=</span><span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>37.Number of Ways to Arrive at Destination</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>37.Number of Ways to Arrive at Destination</h2>
                <p>You are in a city that consists of n intersections numbered from 0 to n - 1 with bi-directional roads between some intersections. The inputs are generated such that you can reach any intersection from any other intersection and that there is at most one road between any two intersections.<br>You are given an integer n and a 2D integer array roads where roads[i] = [ui, vi, timei] means that there is a road between intersections ui and vi that takes timei minutes to travel. You want to know in how many ways you can travel from intersection 0 to intersection n - 1 in the shortest amount of time.<br>Return the number of ways you can arrive at your destination in the shortest amount of time. Since the answer may be large, return it modulo 109 + 7.<br> <br>Example 1:<br><br><br>Input: n = 7, roads = [[0,6,7],[0,1,2],[1,2,3],[1,3,3],[6,3,3],[3,5,1],[6,5,1],[2,5,1],[0,4,5],[4,6,2]]<br>Output: 4<br>Explanation: The shortest amount of time it takes to go from intersection 0 to intersection 6 is 7 minutes.<br>The four ways to get there in 7 minutes are:<br>- 0 ➝ 6<br>- 0 ➝ 4 ➝ 6<br>- 0 ➝ 1 ➝ 2 ➝ 5 ➝ 6<br>- 0 ➝ 1 ➝ 3 ➝ 5 ➝ 6<br><br>Example 2:<br><br>Input: n = 2, roads = [[1,0,10]]<br>Output: 1<br>Explanation: There is only one way to go from intersection 0 to intersection 1, and it takes 10 minutes.<br><br> <br>Constraints:<br><br>1 <= n <= 200<br>n - 1 <= roads.length <= n * (n - 1) / 2<br>roads[i].length == 3<br>0 <= ui, vi <= n - 1<br>1 <= timei <= 109<br>ui != vi<br>There is at most one road connecting any two intersections.<br>You can reach any intersection from any other intersection.<br><br></p>
                <a href=https://leetcode.com/problems/number-of-ways-to-arrive-at-destination>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">heapq</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">find_shortest_path_length</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">adj_list</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
        <span class="n">queue</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="n">s</span><span class="p">))</span>
        <span class="n">dist</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">count_dist</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
        <span class="n">count_dist</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="p">):</span>
            <span class="n">c_dist</span> <span class="p">,</span> <span class="n">c_node</span> <span class="o">=</span> <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">v_node</span><span class="p">,</span> <span class="n">v_w</span> <span class="ow">in</span> <span class="n">adj_list</span><span class="p">[</span><span class="n">c_node</span><span class="p">]:</span>
                <span class="n">v_dist</span> <span class="o">=</span> <span class="n">c_dist</span> <span class="o">+</span> <span class="n">v_w</span>
                <span class="k">if</span> <span class="n">v_dist</span> <span class="o">&lt;</span> <span class="n">dist</span><span class="p">[</span><span class="n">v_node</span><span class="p">]:</span>
                    <span class="n">dist</span><span class="p">[</span><span class="n">v_node</span><span class="p">]</span> <span class="o">=</span> <span class="n">v_dist</span>
                    <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="p">(</span><span class="n">v_dist</span><span class="p">,</span> <span class="n">v_node</span><span class="p">))</span>
                    <span class="n">count_dist</span><span class="p">[</span><span class="n">v_node</span><span class="p">]</span> <span class="o">=</span> <span class="n">count_dist</span><span class="p">[</span><span class="n">c_node</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">v_dist</span> <span class="o">==</span> <span class="n">dist</span><span class="p">[</span><span class="n">v_node</span><span class="p">]:</span>
                    <span class="n">count_dist</span><span class="p">[</span><span class="n">v_node</span><span class="p">]</span> <span class="o">+=</span> <span class="n">count_dist</span><span class="p">[</span><span class="n">c_node</span><span class="p">]</span>
        <span class="c1"># for i in range(n):</span>
        <span class="c1">#     print (i, count_dist[i])</span>
        <span class="n">mod</span> <span class="o">=</span> <span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="mi">9</span><span class="p">)</span><span class="o">+</span><span class="mi">7</span>
        <span class="k">return</span> <span class="n">count_dist</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">%</span> <span class="n">mod</span>

    <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c_node</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">adj_list</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">visited</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">c_node</span> <span class="o">==</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">+=</span><span class="mi">1</span>
            <span class="k">return</span> 
        <span class="k">if</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span><span class="k">return</span>
        <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">c_node</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">v_node</span><span class="p">,</span> <span class="n">v_w</span> <span class="ow">in</span> <span class="n">adj_list</span><span class="p">[</span><span class="n">c_node</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">v_node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dfs</span><span class="p">(</span><span class="n">v_node</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">adj_list</span><span class="p">,</span> <span class="n">d</span><span class="o">-</span><span class="n">v_w</span><span class="p">,</span> <span class="n">visited</span><span class="p">)</span>
        <span class="n">visited</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">c_node</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">countPaths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">roads</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">adj_list</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">roads</span><span class="p">:</span>
            <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">r</span>
            <span class="n">adj_list</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">))</span>
            <span class="n">adj_list</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="n">w</span><span class="p">))</span>
        
        <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">shortest_path_len</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_shortest_path_length</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">adj_list</span><span class="p">)</span> <span class="c1"># O ( V + E l o g V )</span>
        <span class="c1"># self.dfs(0, n, adj_list, shortest_path_len, visited) # O(V)</span>
        <span class="k">return</span> <span class="n">shortest_path_len</span>
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>38.Middle of the Linked List</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>38.Middle of the Linked List</h2>
                <p>Given the head of a singly linked list, return the middle node of the linked list.<br>If there are two middle nodes, return the second middle node.<br> <br>Example 1:<br><br><br>Input: head = [1,2,3,4,5]<br>Output: [3,4,5]<br>Explanation: The middle node of the list is node 3.<br><br>Example 2:<br><br><br>Input: head = [1,2,3,4,5,6]<br>Output: [4,5,6]<br>Explanation: Since the list has two middle nodes with values 3 and 4, we return the second one.<br><br> <br>Constraints:<br><br>The number of nodes in the list is in the range [1, 100].<br>1 <= Node.val <= 100<br><br></p>
                <a href=https://leetcode.com/problems/middle-of-the-linked-list>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="c1"># Definition for singly-linked list.</span>
<span class="c1"># class ListNode:</span>
<span class="c1">#     def __init__(self, val=0, next=None):</span>
<span class="c1">#         self.val = val</span>
<span class="c1">#         self.next = next</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">middleNode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">head</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">]:</span>
        
        <span class="n">slow</span><span class="p">,</span> <span class="n">fast</span> <span class="o">=</span> <span class="n">head</span><span class="p">,</span> <span class="n">head</span>

        <span class="k">while</span> <span class="n">fast</span> <span class="ow">and</span> <span class="n">fast</span><span class="o">.</span><span class="n">next</span><span class="p">:</span>
            <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">.</span><span class="n">next</span>
            <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">.</span><span class="n">next</span><span class="o">.</span><span class="n">next</span>
        
        <span class="k">return</span> <span class="n">slow</span>
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>39.Clone Graph</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>39.Clone Graph</h2>
                <p>Given a reference of a node in a connected undirected graph.<br>Return a deep copy (clone) of the graph.<br>Each node in the graph contains a value (int) and a list (List[Node]) of its neighbors.<br><br>class Node {<br>    public int val;<br>    public List<Node> neighbors;<br>}<br><br> <br>Test case format:<br>For simplicity, each node's value is the same as the node's index (1-indexed). For example, the first node with val == 1, the second node with val == 2, and so on. The graph is represented in the test case using an adjacency list.<br>An adjacency list is a collection of unordered lists used to represent a finite graph. Each list describes the set of neighbors of a node in the graph.<br>The given node will always be the first node with val = 1. You must return the copy of the given node as a reference to the cloned graph.<br> <br>Example 1:<br><br><br>Input: adjList = [[2,4],[1,3],[2,4],[1,3]]<br>Output: [[2,4],[1,3],[2,4],[1,3]]<br>Explanation: There are 4 nodes in the graph.<br>1st node (val = 1)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).<br>2nd node (val = 2)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).<br>3rd node (val = 3)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).<br>4th node (val = 4)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).<br><br>Example 2:<br><br><br>Input: adjList = [[]]<br>Output: [[]]<br>Explanation: Note that the input contains one empty list. The graph consists of only one node with val = 1 and it does not have any neighbors.<br><br>Example 3:<br><br>Input: adjList = []<br>Output: []<br>Explanation: This an empty graph, it does not have any nodes.<br><br> <br>Constraints:<br><br>The number of nodes in the graph is in the range [0, 100].<br>1 <= Node.val <= 100<br>Node.val is unique for each node.<br>There are no repeated edges and no self-loops in the graph.<br>The Graph is connected and all nodes can be visited starting from the given node.<br><br></p>
                <a href=https://leetcode.com/problems/clone-graph>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd"># Definition for a Node.</span>
<span class="sd">class Node:</span>
<span class="sd">    def __init__(self, val = 0, neighbors = None):</span>
<span class="sd">        self.val = val</span>
<span class="sd">        self.neighbors = neighbors if neighbors is not None else []</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">_clone</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">val</span>
        <span class="k">if</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_map</span><span class="p">:</span>
            <span class="n">new_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_map</span><span class="p">[</span><span class="n">val</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">new_node</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_node</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">node_map</span><span class="p">[</span><span class="n">val</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_node</span>
        
        <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">neighbors</span><span class="p">:</span>
            <span class="n">new_neighbor_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clone</span><span class="p">(</span><span class="n">neighbor</span><span class="p">)</span>
            <span class="n">new_node</span><span class="o">.</span><span class="n">neighbors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_neighbor_node</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">new_node</span>

        
    <span class="k">def</span> <span class="nf">cloneGraph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s1">&#39;Node&#39;</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="s1">&#39;Node&#39;</span><span class="p">]:</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">node_map</span> <span class="o">=</span> <span class="p">{}</span>
        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clone</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>40.Two Sum</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>40.Two Sum</h2>
                <p>Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.<br>You may assume that each input would have exactly one solution, and you may not use the same element twice.<br>You can return the answer in any order.<br> <br>Example 1:<br><br>Input: nums = [2,7,11,15], target = 9<br>Output: [0,1]<br>Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].<br><br>Example 2:<br><br>Input: nums = [3,2,4], target = 6<br>Output: [1,2]<br><br>Example 3:<br><br>Input: nums = [3,3], target = 6<br>Output: [0,1]<br><br> <br>Constraints:<br><br>2 <= nums.length <= 104<br>-109 <= nums[i] <= 109<br>-109 <= target <= 109<br>Only one valid answer exists.<br><br> <br>Follow-up: Can you come up with an algorithm that is less than O(n2) time complexity?</p>
                <a href=https://leetcode.com/problems/two-sum>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">twoSum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="n">nums_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">num</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
        
            <span class="n">compl</span> <span class="o">=</span> <span class="n">target</span><span class="o">-</span><span class="n">num</span>
            <span class="k">if</span> <span class="n">compl</span> <span class="ow">in</span> <span class="n">nums_dict</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">i</span><span class="p">,</span> <span class="n">nums_dict</span><span class="p">[</span><span class="n">compl</span><span class="p">]</span>
            <span class="n">nums_dict</span><span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
        
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>41.Serialize and Deserialize Binary Tree</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>41.Serialize and Deserialize Binary Tree</h2>
                <p>Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.<br>Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.<br>Clarification: The input/output format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.<br> <br>Example 1:<br><br><br>Input: root = [1,2,3,null,null,4,5]<br>Output: [1,2,3,null,null,4,5]<br><br>Example 2:<br><br>Input: root = []<br>Output: []<br><br> <br>Constraints:<br><br>The number of nodes in the tree is in the range [0, 104].<br>-1000 <= Node.val <= 1000<br><br></p>
                <a href=https://leetcode.com/problems/serialize-and-deserialize-binary-tree>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="c1"># Definition for a binary tree node.</span>
<span class="c1"># class TreeNode(object):</span>
<span class="c1">#     def __init__(self, x):</span>
<span class="c1">#         self.val = x</span>
<span class="c1">#         self.left = None</span>
<span class="c1">#         self.right = None</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="sd">1 2 3 N N 4 5 N N N N</span>
<span class="sd"> </span>
<span class="sd">1 2 3 </span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="k">class</span> <span class="nc">Codec</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">_encode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">val</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_encode</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_encode</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
        
    <span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Encodes a tree to a single string.</span>
<span class="sd">        </span>
<span class="sd">        :type root: TreeNode</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_encode</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
        
        <span class="n">data</span> <span class="o">=</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="nb">print</span> <span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">data</span>

    <span class="k">def</span> <span class="nf">deserialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Decodes your encoded data to tree.</span>
<span class="sd">        </span>
<span class="sd">        :type data: str</span>
<span class="sd">        :rtype: TreeNode</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span> <span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)</span>
        <span class="n">indx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">def</span> <span class="nf">_decode</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
            <span class="k">nonlocal</span> <span class="n">indx</span> 
            <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot; &quot;</span><span class="p">:</span>
                <span class="n">indx</span><span class="o">+=</span> <span class="mi">1</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">indx</span><span class="p">]))</span>
            <span class="n">indx</span><span class="o">+=</span> <span class="mi">1</span>
            <span class="n">node</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">_decode</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="n">node</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">_decode</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">node</span>

        <span class="n">root</span> <span class="o">=</span> <span class="n">_decode</span><span class="p">(</span><span class="n">data</span> <span class="p">)</span>
        <span class="k">return</span> <span class="n">root</span>
        

<span class="c1"># Your Codec object will be instantiated and called as such:</span>
<span class="c1"># ser = Codec()</span>
<span class="c1"># deser = Codec()</span>
<span class="c1"># ans = deser.deserialize(ser.serialize(root))</span>
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>42.Reverse Linked List</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>42.Reverse Linked List</h2>
                <p>Given the head of a singly linked list, reverse the list, and return the reversed list.<br> <br>Example 1:<br><br><br>Input: head = [1,2,3,4,5]<br>Output: [5,4,3,2,1]<br><br>Example 2:<br><br><br>Input: head = [1,2]<br>Output: [2,1]<br><br>Example 3:<br><br>Input: head = []<br>Output: []<br><br> <br>Constraints:<br><br>The number of nodes in the list is the range [0, 5000].<br>-5000 <= Node.val <= 5000<br><br> <br>Follow up: A linked list can be reversed either iteratively or recursively. Could you implement both?<br></p>
                <a href=https://leetcode.com/problems/reverse-linked-list>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="c1"># Definition for singly-linked list.</span>
<span class="c1"># class ListNode:</span>
<span class="c1">#     def __init__(self, val=0, next=None):</span>
<span class="c1">#         self.val = val</span>
<span class="c1">#         self.next = next</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">reverseList</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">head</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">]:</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">while</span> <span class="n">head</span><span class="p">:</span>
            <span class="n">next_ptr</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="n">next</span>
            <span class="n">head</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">prev</span>

            <span class="n">prev</span> <span class="o">=</span> <span class="n">head</span>
            <span class="n">head</span> <span class="o">=</span> <span class="n">next_ptr</span>
        <span class="k">return</span> <span class="n">prev</span>
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>43.House Robber</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>43.House Robber</h2>
                <p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.<br>Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.<br> <br>Example 1:<br><br>Input: nums = [1,2,3,1]<br>Output: 4<br>Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).<br>Total amount you can rob = 1 + 3 = 4.<br><br>Example 2:<br><br>Input: nums = [2,7,9,3,1]<br>Output: 12<br>Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).<br>Total amount you can rob = 2 + 9 + 1 = 12.<br><br> <br>Constraints:<br><br>1 <= nums.length <= 100<br>0 <= nums[i] <= 400<br><br></p>
                <a href=https://leetcode.com/problems/house-robber>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">rob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="n">rob_max</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
        
        <span class="n">rob_max</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">rob_max</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> 

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
            <span class="n">rob_max</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">rob_max</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">rob_max</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        
        <span class="k">return</span> <span class="n">rob_max</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>44.Network Delay Time</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>44.Network Delay Time</h2>
                <p>You are given a network of n nodes, labeled from 1 to n. You are also given times, a list of travel times as directed edges times[i] = (ui, vi, wi), where ui is the source node, vi is the target node, and wi is the time it takes for a signal to travel from source to target.<br>We will send a signal from a given node k. Return the minimum time it takes for all the n nodes to receive the signal. If it is impossible for all the n nodes to receive the signal, return -1.<br> <br>Example 1:<br><br><br>Input: times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2<br>Output: 2<br><br>Example 2:<br><br>Input: times = [[1,2,1]], n = 2, k = 1<br>Output: 1<br><br>Example 3:<br><br>Input: times = [[1,2,1]], n = 2, k = 2<br>Output: -1<br><br> <br>Constraints:<br><br>1 <= k <= n <= 100<br>1 <= times.length <= 6000<br>times[i].length == 3<br>1 <= ui, vi <= n<br>ui != vi<br>0 <= wi <= 100<br>All the pairs (ui, vi) are unique. (i.e., no multiple edges.)<br><br></p>
                <a href=https://leetcode.com/problems/network-delay-time>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">heapq</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">networkDelayTime</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">times</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">adj_list</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">adj_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">time</span> <span class="ow">in</span> <span class="n">times</span><span class="p">:</span>
            <span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">w</span> <span class="o">=</span> <span class="n">time</span>
            <span class="n">adj_list</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">v</span><span class="p">,</span><span class="n">w</span><span class="p">))</span>

        <span class="n">pq</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">pq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="p">)</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="n">dist</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">pq</span><span class="p">):</span>
            <span class="n">dist_u</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">pq</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">v</span><span class="p">,</span><span class="n">w</span> <span class="ow">in</span> <span class="n">adj_list</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
                <span class="n">dist_v</span> <span class="o">=</span> <span class="n">dist_u</span> <span class="o">+</span> <span class="n">w</span>
                <span class="k">if</span> <span class="n">dist_v</span> <span class="o">&lt;</span> <span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
                    <span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist_v</span>
                    <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">pq</span><span class="p">,</span> <span class="p">(</span><span class="n">dist_v</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
                    <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="c1"># print (visited, dist, k)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">visited</span><span class="p">)</span><span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>45.Jump Game</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>45.Jump Game</h2>
                <p>You are given an integer array nums. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position.<br>Return true if you can reach the last index, or false otherwise.<br> <br>Example 1:<br><br>Input: nums = [2,3,1,1,4]<br>Output: true<br>Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.<br><br>Example 2:<br><br>Input: nums = [3,2,1,0,4]<br>Output: false<br>Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.<br><br> <br>Constraints:<br><br>1 <= nums.length <= 104<br>0 <= nums[i] <= 105<br><br></p>
                <a href=https://leetcode.com/problems/jump-game>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    3 2 1 0 4</span>
<span class="sd">    p = 3, 2, 1, </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">canJump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">p_power</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">c_power</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">p_power</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">c_power</span><span class="p">,</span> <span class="n">p_power</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

            <span class="k">if</span>  <span class="n">p_power</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
        
        <span class="k">return</span> <span class="kc">True</span>
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>46.House Robber II</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>46.House Robber II</h2>
                <p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and it will automatically contact the police if two adjacent houses were broken into on the same night.<br>Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.<br> <br>Example 1:<br><br>Input: nums = [2,3,2]<br>Output: 3<br>Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.<br><br>Example 2:<br><br>Input: nums = [1,2,3,1]<br>Output: 4<br>Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).<br>Total amount you can rob = 1 + 3 = 4.<br><br>Example 3:<br><br>Input: nums = [1,2,3]<br>Output: 3<br><br> <br>Constraints:<br><br>1 <= nums.length <= 100<br>0 <= nums[i] <= 1000<br><br></p>
                <a href=https://leetcode.com/problems/house-robber-ii>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">_rob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">):</span>
        <span class="n">rob_amount</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">prev2</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">prev1</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
            <span class="n">num</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">rob_amount</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">num</span> <span class="o">+</span> <span class="n">prev2</span><span class="p">,</span> <span class="n">prev1</span><span class="p">)</span>
            <span class="n">prev2</span> <span class="o">=</span> <span class="n">prev1</span>
            <span class="n">prev1</span> <span class="o">=</span> <span class="n">rob_amount</span>
        <span class="k">return</span> <span class="n">prev1</span>

    <span class="k">def</span> <span class="nf">rob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rob</span><span class="p">(</span><span class="n">nums</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rob</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>47.Design Add and Search Words Data Structure</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>47.Design Add and Search Words Data Structure</h2>
                <p>Design a data structure that supports adding new words and finding if a string matches any previously added string.<br>Implement the WordDictionary class:<br><br>WordDictionary() Initializes the object.<br>void addWord(word) Adds word to the data structure, it can be matched later.<br>bool search(word) Returns true if there is any string in the data structure that matches word or false otherwise. word may contain dots '.' where dots can be matched with any letter.<br><br> <br>Example:<br><br>Input<br>["WordDictionary","addWord","addWord","addWord","search","search","search","search"]<br>[[],["bad"],["dad"],["mad"],["pad"],["bad"],[".ad"],["b.."]]<br>Output<br>[null,null,null,null,false,true,true,true]<br><br>Explanation<br>WordDictionary wordDictionary = new WordDictionary();<br>wordDictionary.addWord("bad");<br>wordDictionary.addWord("dad");<br>wordDictionary.addWord("mad");<br>wordDictionary.search("pad"); // return False<br>wordDictionary.search("bad"); // return True<br>wordDictionary.search(".ad"); // return True<br>wordDictionary.search("b.."); // return True<br><br> <br>Constraints:<br><br>1 <= word.length <= 25<br>word in addWord consists of lowercase English letters.<br>word in search consist of '.' or lowercase English letters.<br>There will be at most 2 dots in word for search queries.<br>At most 104 calls will be made to addWord and search.<br><br></p>
                <a href=https://leetcode.com/problems/design-add-and-search-words-data-structure>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Trie</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">childs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_word</span> <span class="o">=</span> <span class="kc">False</span>

<span class="k">class</span> <span class="nc">WordDictionary</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">Trie</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">addWord</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">root</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">word</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">childs</span><span class="p">:</span>
                <span class="c1">#root = root.childs[c]</span>
                <span class="n">root</span><span class="o">.</span><span class="n">childs</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">Trie</span><span class="p">()</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">childs</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
        <span class="n">root</span><span class="o">.</span><span class="n">is_word</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">root</span> <span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">root</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">word</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">c</span><span class="o">==</span><span class="s2">&quot;.&quot;</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">childs</span><span class="p">:</span>
                    <span class="n">status</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">word</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:],</span> <span class="n">root</span><span class="o">.</span><span class="n">childs</span><span class="p">[</span><span class="n">child</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">status</span><span class="p">:</span>
                        <span class="k">return</span> <span class="kc">True</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">elif</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">childs</span><span class="p">:</span>
                <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">childs</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">root</span><span class="o">.</span><span class="n">is_word</span>


<span class="c1"># Your WordDictionary object will be instantiated and called as such:</span>
<span class="c1"># obj = WordDictionary()</span>
<span class="c1"># obj.addWord(word)</span>
<span class="c1"># param_2 = obj.search(word)</span>
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>48.Implement Trie (Prefix Tree)</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>48.Implement Trie (Prefix Tree)</h2>
                <p>A trie (pronounced as "try") or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.<br>Implement the Trie class:<br><br>Trie() Initializes the trie object.<br>void insert(String word) Inserts the string word into the trie.<br>boolean search(String word) Returns true if the string word is in the trie (i.e., was inserted before), and false otherwise.<br>boolean startsWith(String prefix) Returns true if there is a previously inserted string word that has the prefix prefix, and false otherwise.<br><br> <br>Example 1:<br><br>Input<br>["Trie", "insert", "search", "search", "startsWith", "insert", "search"]<br>[[], ["apple"], ["apple"], ["app"], ["app"], ["app"], ["app"]]<br>Output<br>[null, null, true, false, true, null, true]<br><br>Explanation<br>Trie trie = new Trie();<br>trie.insert("apple");<br>trie.search("apple");   // return True<br>trie.search("app");     // return False<br>trie.startsWith("app"); // return True<br>trie.insert("app");<br>trie.search("app");     // return True<br><br> <br>Constraints:<br><br>1 <= word.length, prefix.length <= 2000<br>word and prefix consist only of lowercase English letters.<br>At most 3 * 104 calls in total will be made to insert, search, and startsWith.<br><br></p>
                <a href=https://leetcode.com/problems/implement-trie-prefix-tree>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">childrens</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_word</span> <span class="o">=</span> <span class="kc">False</span>


<span class="k">class</span> <span class="nc">Trie</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">Node</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">word</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">childrens</span><span class="p">:</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">childrens</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">node</span><span class="o">.</span><span class="n">childrens</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">Node</span><span class="p">()</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">childrens</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
        <span class="n">node</span><span class="o">.</span><span class="n">is_word</span> <span class="o">=</span> <span class="kc">True</span>
            
    <span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">word</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">childrens</span><span class="p">:</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">childrens</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">is_word</span>

    <span class="k">def</span> <span class="nf">startsWith</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prefix</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span>

        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">prefix</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">childrens</span><span class="p">:</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">childrens</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>


<span class="c1"># Your Trie object will be instantiated and called as such:</span>
<span class="c1"># obj = Trie()</span>
<span class="c1"># obj.insert(word)</span>
<span class="c1"># param_2 = obj.search(word)</span>
<span class="c1"># param_3 = obj.startsWith(prefix)</span>
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>49.Search in Rotated Sorted Array</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>49.Search in Rotated Sorted Array</h2>
                <p>There is an integer array nums sorted in ascending order (with distinct values).<br>Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].<br>Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.<br>You must write an algorithm with O(log n) runtime complexity.<br> <br>Example 1:<br>Input: nums = [4,5,6,7,0,1,2], target = 0<br>Output: 4<br>Example 2:<br>Input: nums = [4,5,6,7,0,1,2], target = 3<br>Output: -1<br>Example 3:<br>Input: nums = [1], target = 0<br>Output: -1<br><br> <br>Constraints:<br><br>1 <= nums.length <= 5000<br>-104 <= nums[i] <= 104<br>All values of nums are unique.<br>nums is an ascending array that is possibly rotated.<br>-104 <= target <= 104<br><br></p>
                <a href=https://leetcode.com/problems/search-in-rotated-sorted-array>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">_get_pivot_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">):</span>
        <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">left</span> <span class="o">&lt;=</span><span class="n">right</span><span class="p">:</span>
            <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">left</span><span class="o">+</span><span class="n">right</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
            <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span>  <span class="o">&lt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">[(</span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">n</span><span class="p">]:</span>
                <span class="k">return</span> <span class="n">mid</span>
            <span class="k">elif</span> <span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]:</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span><span class="mi">1</span> 
        <span class="k">return</span> <span class="n">mid</span>

    <span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">pivot_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_pivot_index</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
        
        <span class="n">start</span> <span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">pivot_idx</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">pivot_idx</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">target</span>  <span class="o">&lt;=</span> <span class="n">nums</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="n">pivot_idx</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span>
        
        <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span>
        <span class="k">while</span> <span class="n">start</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">:</span>
            <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">start</span><span class="o">+</span><span class="n">end</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
            <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">mid</span>
            <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">target</span>  <span class="o">&lt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]:</span>
                    <span class="n">end</span> <span class="o">=</span> <span class="n">mid</span><span class="o">-</span><span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">start</span> <span class="o">=</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">target</span>  <span class="o">&lt;=</span> <span class="n">nums</span><span class="p">[</span><span class="n">end</span><span class="p">]:</span>
                    <span class="n">start</span> <span class="o">=</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">end</span> <span class="o">=</span> <span class="n">mid</span><span class="o">-</span><span class="mi">1</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>51.Binary Search Tree Iterator</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>51.Binary Search Tree Iterator</h2>
                <p>Implement the BSTIterator class that represents an iterator over the in-order traversal of a binary search tree (BST):<br><br>BSTIterator(TreeNode root) Initializes an object of the BSTIterator class. The root of the BST is given as part of the constructor. The pointer should be initialized to a non-existent number smaller than any element in the BST.<br>boolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false.<br>int next() Moves the pointer to the right, then returns the number at the pointer.<br><br>Notice that by initializing the pointer to a non-existent smallest number, the first call to next() will return the smallest element in the BST.<br>You may assume that next() calls will always be valid. That is, there will be at least a next number in the in-order traversal when next() is called.<br> <br>Example 1:<br><br><br>Input<br>["BSTIterator", "next", "next", "hasNext", "next", "hasNext", "next", "hasNext", "next", "hasNext"]<br>[[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]<br>Output<br>[null, 3, 7, true, 9, true, 15, true, 20, false]<br><br>Explanation<br>BSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);<br>bSTIterator.next();    // return 3<br>bSTIterator.next();    // return 7<br>bSTIterator.hasNext(); // return True<br>bSTIterator.next();    // return 9<br>bSTIterator.hasNext(); // return True<br>bSTIterator.next();    // return 15<br>bSTIterator.hasNext(); // return True<br>bSTIterator.next();    // return 20<br>bSTIterator.hasNext(); // return False<br><br> <br>Constraints:<br><br>The number of nodes in the tree is in the range [1, 105].<br>0 <= Node.val <= 106<br>At most 105 calls will be made to hasNext, and next.<br><br> <br>Follow up:<br><br>Could you implement next() and hasNext() to run in average O(1) time and use O(h) memory, where h is the height of the tree?<br><br></p>
                <a href=https://leetcode.com/problems/binary-search-tree-iterator>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="c1"># Definition for a binary tree node.</span>
<span class="c1"># class TreeNode:</span>
<span class="c1">#     def __init__(self, val=0, left=None, right=None):</span>
<span class="c1">#         self.val = val</span>
<span class="c1">#         self.left = left</span>
<span class="c1">#         self.right = right</span>
<span class="k">class</span> <span class="nc">BSTIterator</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">]):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">root</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c_ptr</span> <span class="o">=</span> <span class="n">root</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">preorder</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
        
    <span class="k">def</span> <span class="nf">preorder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>  
        <span class="k">while</span> <span class="n">root</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">left</span>
    
    <span class="k">def</span> <span class="nf">next</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">preorder</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">val</span>
            

    <span class="k">def</span> <span class="nf">hasNext</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>


<span class="c1"># Your BSTIterator object will be instantiated and called as such:</span>
<span class="c1"># obj = BSTIterator(root)</span>
<span class="c1"># param_1 = obj.next()</span>
<span class="c1"># param_2 = obj.hasNext()</span>
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>52.Longest Increasing Subsequence</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>52.Longest Increasing Subsequence</h2>
                <p>Given an integer array nums, return the length of the longest strictly increasing subsequence.<br> <br>Example 1:<br><br>Input: nums = [10,9,2,5,3,7,101,18]<br>Output: 4<br>Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.<br><br>Example 2:<br><br>Input: nums = [0,1,0,3,2,3]<br>Output: 4<br><br>Example 3:<br><br>Input: nums = [7,7,7,7,7,7,7]<br>Output: 1<br><br> <br>Constraints:<br><br>1 <= nums.length <= 2500<br>-104 <= nums[i] <= 104<br><br> <br>Follow up: Can you come up with an algorithm that runs in O(n log(n)) time complexity?<br></p>
                <a href=https://leetcode.com/problems/longest-increasing-subsequence>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">_max_lis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">,</span> <span class="n">idx</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">memo</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">!=-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">memo</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        
        <span class="n">lis</span> <span class="o">=</span> <span class="mi">0</span> 
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
            <span class="n">next_num</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">next_num</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">idx</span><span class="p">]:</span>
                <span class="n">c_lis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_lis</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
                <span class="n">lis</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">lis</span><span class="p">,</span> <span class="n">c_lis</span><span class="p">)</span>
        <span class="n">lis</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">memo</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">lis</span>
        <span class="k">return</span> <span class="n">lis</span>

    <span class="k">def</span> <span class="nf">lengthOfLIS</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">memo</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">))]</span>
        <span class="n">len_lis</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">memo</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">==-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">c_lis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_lis</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">c_lis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">memo</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="n">len_lis</span><span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">len_lis</span><span class="p">,</span> <span class="n">c_lis</span><span class="p">)</span>    
        <span class="k">return</span> <span class="n">len_lis</span>


            
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>53.Rotate Image</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>53.Rotate Image</h2>
                <p>You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).<br>You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.<br> <br>Example 1:<br><br><br>Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]<br>Output: [[7,4,1],[8,5,2],[9,6,3]]<br><br>Example 2:<br><br><br>Input: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]<br>Output: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]<br><br> <br>Constraints:<br><br>n == matrix.length == matrix[i].length<br>1 <= n <= 20<br>-1000 <= matrix[i][j] <= 1000<br><br></p>
                <a href=https://leetcode.com/problems/rotate-image>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">rotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">matrix</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Do not return anything, modify matrix in-place instead.</span>
<span class="sd">        0,0 -&gt; 0,2. </span>
<span class="sd">        0,1 -&gt; 1,2    </span>
<span class="sd">        0,2 -&gt; 2,2.  </span>

<span class="sd">        Relation</span>

<span class="sd">        new r1, c1 = c , n-r-1</span>

<span class="sd">        Two steps </span>
<span class="sd">            r1, c1 = c, n-r-1 =c, r =&gt; Transpose then invert</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># find transpose</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">matrix</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
                <span class="n">matrix</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">],</span>  <span class="n">matrix</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="n">r</span><span class="p">],</span> <span class="n">matrix</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]</span>
        
        <span class="c1"># flip vertical</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="o">//</span><span class="mi">2</span><span class="p">):</span>
                <span class="n">matrix</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">],</span> <span class="n">matrix</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="n">c</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="n">c</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">matrix</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">matrix</span> 




        
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>54.Maximum Product Subarray</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>54.Maximum Product Subarray</h2>
                <p>Given an integer array nums, find a subarray that has the largest product, and return the product.<br>The test cases are generated so that the answer will fit in a 32-bit integer.<br> <br>Example 1:<br><br>Input: nums = [2,3,-2,4]<br>Output: 6<br>Explanation: [2,3] has the largest product 6.<br><br>Example 2:<br><br>Input: nums = [-2,0,-1]<br>Output: 0<br>Explanation: The result cannot be 2, because [-2,-1] is not a subarray.<br><br> <br>Constraints:<br><br>1 <= nums.length <= 2 * 104<br>-10 <= nums[i] <= 10<br>The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.<br><br></p>
                <a href=https://leetcode.com/problems/maximum-product-subarray>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">maxProduct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        split based on zero</span>
<span class="sd">        2    1   -2   4</span>
<span class="sd">        2     2  -12 -24</span>
<span class="sd">        -96  -48 -8   4</span>
<span class="sd">        2.   2.   -8.  4</span>

<span class="sd">        -2    2.  4    4   -2   -1</span>
<span class="sd">        -2.  -4  -16  -64  128. -128</span>
<span class="sd">       -128   64  32    8    2    -1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
        <span class="n">max_product</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">c_left_product</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">c_right_product</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
            <span class="n">left_num</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">right_num</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">c_left_product</span> <span class="o">=</span> <span class="n">c_left_product</span> <span class="o">*</span> <span class="n">left_num</span> <span class="k">if</span> <span class="n">c_left_product</span> <span class="o">!=</span><span class="mi">0</span> <span class="k">else</span> <span class="n">left_num</span>
            <span class="n">c_right_product</span> <span class="o">=</span> <span class="n">c_right_product</span> <span class="o">*</span> <span class="n">right_num</span> <span class="k">if</span> <span class="n">c_right_product</span> <span class="o">!=</span><span class="mi">0</span> <span class="k">else</span> <span class="n">right_num</span>

            <span class="n">max_product</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_product</span><span class="p">,</span> <span class="n">c_left_product</span><span class="p">,</span> <span class="n">c_right_product</span><span class="p">)</span>
            
        <span class="c1">#max_product = max(max(left_products), max(right_products))</span>
        <span class="k">return</span> <span class="n">max_product</span>
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>55.Longest Substring Without Repeating Characters</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>55.Longest Substring Without Repeating Characters</h2>
                <p>Given a string s, find the length of the longest substring without repeating characters.<br> <br>Example 1:<br><br>Input: s = "abcabcbb"<br>Output: 3<br>Explanation: The answer is "abc", with the length of 3.<br><br>Example 2:<br><br>Input: s = "bbbbb"<br>Output: 1<br>Explanation: The answer is "b", with the length of 1.<br><br>Example 3:<br><br>Input: s = "pwwkew"<br>Output: 3<br>Explanation: The answer is "wke", with the length of 3.<br>Notice that the answer must be a substring, "pwke" is a subsequence and not a substring.<br><br> <br>Constraints:<br><br>0 <= s.length <= 5 * 104<br>s consists of English letters, digits, symbols and spaces.<br><br></p>
                <a href=https://leetcode.com/problems/longest-substring-without-repeating-characters>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">lengthOfLongestSubstring</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">s1</span> <span class="o">=</span> <span class="n">s</span>
        <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">longest_substr</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">char_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">e</span><span class="p">,</span><span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">s1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">char_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="mi">0</span><span class="p">):</span>
                <span class="k">while</span> <span class="n">s1</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">!=</span><span class="n">c</span><span class="p">:</span>
                    <span class="n">char_dict</span><span class="p">[</span><span class="n">s1</span><span class="p">[</span><span class="n">s</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">s</span><span class="o">+=</span><span class="mi">1</span>
                <span class="n">char_dict</span><span class="p">[</span><span class="n">s1</span><span class="p">[</span><span class="n">s</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">s</span><span class="o">+=</span><span class="mi">1</span>
            <span class="n">char_dict</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">longest_substr</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">e</span><span class="o">-</span><span class="n">s</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">longest_substr</span><span class="p">)</span>
                
        <span class="k">return</span> <span class="n">longest_substr</span>
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>56.3Sum</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>56.3Sum</h2>
                <p>Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.<br>Notice that the solution set must not contain duplicate triplets.<br> <br>Example 1:<br><br>Input: nums = [-1,0,1,2,-1,-4]<br>Output: [[-1,-1,2],[-1,0,1]]<br>Explanation: <br>nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.<br>nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.<br>nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.<br>The distinct triplets are [-1,0,1] and [-1,-1,2].<br>Notice that the order of the output and the order of the triplets does not matter.<br><br>Example 2:<br><br>Input: nums = [0,1,1]<br>Output: []<br>Explanation: The only possible triplet does not sum up to 0.<br><br>Example 3:<br><br>Input: nums = [0,0,0]<br>Output: [[0,0,0]]<br>Explanation: The only possible triplet sums up to 0.<br><br> <br>Constraints:<br><br>3 <= nums.length <= 3000<br>-105 <= nums[i] <= 105<br><br></p>
                <a href=https://leetcode.com/problems/3sum>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">threeSum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="n">target</span>  <span class="o">=</span> <span class="mi">0</span> 
        <span class="n">nums</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

        <span class="n">triplets</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">nums_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">num</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
            <span class="n">nums_dict</span><span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span>
            <span class="n">nums_dict</span><span class="p">[</span><span class="n">num</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="c1"># print (nums_dict)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
            <span class="n">x</span>  <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">target_3</span> <span class="o">=</span> <span class="n">target</span><span class="o">-</span><span class="n">x</span><span class="o">-</span><span class="n">y</span>
                <span class="k">if</span> <span class="n">target_3</span> <span class="ow">in</span> <span class="n">nums_dict</span><span class="p">:</span>
                    <span class="n">idx</span> <span class="o">=</span> <span class="n">nums_dict</span><span class="p">[</span><span class="n">target_3</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">idx</span><span class="p">:</span>
                        <span class="n">idx</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">idx</span><span class="p">:</span>
                        <span class="n">idx</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                    <span class="c1"># print(x,y, target_3, idx)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
                        <span class="n">triplet</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">target_3</span><span class="p">]</span>
                        <span class="n">triplet</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
                        <span class="n">triplets</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">triplet</span><span class="p">))</span>
        <span class="n">triplets</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">triplets</span><span class="p">)</span>
        <span class="c1"># triplets.sort()</span>
        <span class="k">return</span> <span class="n">triplets</span>
    <span class="k">def</span> <span class="nf">threeSum1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="n">output</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="c1"># nums = sorted(nums)  # O(Nlogn)</span>

        <span class="c1"># [-1, -2, -3 , 0, 1, 1, 2, 3, 4]</span>
        <span class="n">nums_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">num</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
            <span class="n">idx_list</span> <span class="o">=</span> <span class="n">nums_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">num</span><span class="p">,</span><span class="nb">set</span><span class="p">())</span>
            <span class="n">idx_list</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">nums_dict</span><span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx_list</span>
        <span class="c1">#print (nums)</span>
        <span class="k">for</span> <span class="n">idx_a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span> 
            <span class="n">a</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">idx_a</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">idx_b</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
                <span class="n">compl</span> <span class="o">=</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span>
                <span class="k">if</span> <span class="n">idx_a</span> <span class="o">!=</span> <span class="n">idx_b</span> <span class="ow">and</span> <span class="o">-</span><span class="n">compl</span> <span class="ow">in</span> <span class="n">nums_dict</span><span class="p">:</span>
                    <span class="n">idx_c</span> <span class="o">=</span> <span class="kc">None</span>
                    
                    <span class="n">diff_idxs</span> <span class="o">=</span> <span class="n">nums_dict</span><span class="p">[</span><span class="o">-</span><span class="n">compl</span><span class="p">]</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">idx_a</span><span class="p">,</span> <span class="n">idx_b</span><span class="p">]))</span>
                    
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">diff_idxs</span><span class="p">):</span>
                        <span class="n">output</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="o">-</span><span class="n">compl</span><span class="p">])))</span>
                    <span class="c1"># for idx_c, c in enumerate(nums_dict[-compl]):</span>
                    <span class="c1">#     if idx_a != idx_b and idx_a!=c and idx_b!=c:</span>
                    <span class="c1">#         output.add(tuple(sorted([a, b, -compl])))</span>
        <span class="c1"># output = set(output)</span>
        <span class="k">return</span> <span class="n">output</span>
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>57.Validate IP Address</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>57.Validate IP Address</h2>
                <p>Given a string queryIP, return "IPv4" if IP is a valid IPv4 address, "IPv6" if IP is a valid IPv6 address or "Neither" if IP is not a correct IP of any type.<br>A valid IPv4 address is an IP in the form "x1.x2.x3.x4" where 0 <= xi <= 255 and xi cannot contain leading zeros. For example, "192.168.1.1" and "192.168.1.0" are valid IPv4 addresses while "192.168.01.1", "192.168.1.00", and "192.168@1.1" are invalid IPv4 addresses.<br>A valid IPv6 address is an IP in the form "x1:x2:x3:x4:x5:x6:x7:x8" where:<br><br>1 <= xi.length <= 4<br>xi is a hexadecimal string which may contain digits, lowercase English letter ('a' to 'f') and upper-case English letters ('A' to 'F').<br>Leading zeros are allowed in xi.<br><br>For example, "2001:0db8:85a3:0000:0000:8a2e:0370:7334" and "2001:db8:85a3:0:0:8A2E:0370:7334" are valid IPv6 addresses, while "2001:0db8:85a3::8A2E:037j:7334" and "02001:0db8:85a3:0000:0000:8a2e:0370:7334" are invalid IPv6 addresses.<br> <br>Example 1:<br><br>Input: queryIP = "172.16.254.1"<br>Output: "IPv4"<br>Explanation: This is a valid IPv4 address, return "IPv4".<br><br>Example 2:<br><br>Input: queryIP = "2001:0db8:85a3:0:0:8A2E:0370:7334"<br>Output: "IPv6"<br>Explanation: This is a valid IPv6 address, return "IPv6".<br><br>Example 3:<br><br>Input: queryIP = "256.256.256.256"<br>Output: "Neither"<br>Explanation: This is neither a IPv4 address nor a IPv6 address.<br><br> <br>Constraints:<br><br>queryIP consists only of English letters, digits and the characters '.' and ':'.<br><br></p>
                <a href=https://leetcode.com/problems/validate-ip-address>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">check_valid_ipv4</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ip_split</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ip_split</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">c</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
                    <span class="k">return</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">x</span><span class="o">==</span><span class="s2">&quot;&quot;</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;0&quot;</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="mi">0</span><span class="o">&lt;=</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">255</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>
    
    <span class="k">def</span> <span class="nf">check_valid_ipv6</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ip_split</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ip_split</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">x</span><span class="o">==</span><span class="s2">&quot;&quot;</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">4</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span> <span class="n">c</span><span class="o">.</span><span class="n">isdigit</span><span class="p">()</span> <span class="ow">or</span> <span class="s2">&quot;a&quot;</span><span class="o">&lt;=</span><span class="n">c</span><span class="o">&lt;=</span><span class="s2">&quot;f&quot;</span> <span class="ow">or</span> <span class="s2">&quot;A&quot;</span><span class="o">&lt;=</span><span class="n">c</span><span class="o">&lt;=</span><span class="s2">&quot;F&quot;</span><span class="p">):</span>
                    <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>
                
    <span class="k">def</span> <span class="nf">validIPAddress</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">queryIP</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="c1"># check if ipv4</span>
        <span class="nb">type</span> <span class="o">=</span> <span class="s2">&quot;Neither&quot;</span>
        <span class="n">ip_split</span> <span class="o">=</span> <span class="n">queryIP</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ip_split</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">valid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_valid_ipv4</span><span class="p">(</span><span class="n">ip_split</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">valid</span><span class="p">:</span>
                <span class="nb">type</span> <span class="o">=</span> <span class="s2">&quot;IPv4&quot;</span>
            
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ip_split</span> <span class="o">=</span> <span class="n">queryIP</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ip_split</span><span class="p">)</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span>
                <span class="n">valid</span> <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">check_valid_ipv6</span><span class="p">(</span><span class="n">ip_split</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">valid</span><span class="p">:</span>
                    <span class="nb">type</span> <span class="o">=</span> <span class="s2">&quot;IPv6&quot;</span>
        
        <span class="k">return</span> <span class="nb">type</span>
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>58.Non-overlapping Intervals</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>58.Non-overlapping Intervals</h2>
                <p>Given an array of intervals intervals where intervals[i] = [starti, endi], return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.<br> <br>Example 1:<br><br>Input: intervals = [[1,2],[2,3],[3,4],[1,3]]<br>Output: 1<br>Explanation: [1,3] can be removed and the rest of the intervals are non-overlapping.<br><br>Example 2:<br><br>Input: intervals = [[1,2],[1,2],[1,2]]<br>Output: 2<br>Explanation: You need to remove two [1,2] to make the rest of the intervals non-overlapping.<br><br>Example 3:<br><br>Input: intervals = [[1,2],[2,3]]<br>Output: 0<br>Explanation: You don't need to remove any of the intervals since they're already non-overlapping.<br><br> <br>Constraints:<br><br>1 <= intervals.length <= 105<br>intervals[i].length == 2<br>-5 * 104 <= starti < endi <= 5 * 104<br><br></p>
                <a href=https://leetcode.com/problems/non-overlapping-intervals>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">eraseOverlapIntervals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">intervals</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">sorted_intervals</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="c1"># print (sorted_intervals)</span>
        <span class="n">last_interval</span> <span class="o">=</span> <span class="n">sorted_intervals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">min_removal</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">intervals</span><span class="p">)):</span>
            <span class="n">c_interval</span> <span class="o">=</span> <span class="n">sorted_intervals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">cs</span><span class="p">,</span> <span class="n">ce</span> <span class="o">=</span> <span class="n">c_interval</span>
            <span class="n">ls</span><span class="p">,</span> <span class="n">le</span> <span class="o">=</span> <span class="n">last_interval</span>
            
            <span class="k">if</span> <span class="n">cs</span> <span class="o">&lt;</span> <span class="n">le</span><span class="p">:</span>
                <span class="n">min_removal</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">ce</span> <span class="o">&gt;</span> <span class="n">le</span><span class="p">:</span>
                    <span class="n">c_interval</span> <span class="o">=</span> <span class="n">last_interval</span>
            
            <span class="c1"># print (c_interval, last_interval)</span>
            <span class="n">last_interval</span> <span class="o">=</span> <span class="n">c_interval</span>

            
        
        <span class="k">return</span> <span class="n">min_removal</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">(1,100), (1,11), (2,12), (11,22)</span>
<span class="sd">prev = (1,100),x (1,11)</span>
<span class="sd">c = (1, 11)x (2, 12) x (11, 22)</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>59.Subtree of Another Tree</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>59.Subtree of Another Tree</h2>
                <p>Given the roots of two binary trees root and subRoot, return true if there is a subtree of root with the same structure and node values of subRoot and false otherwise.<br>A subtree of a binary tree tree is a tree that consists of a node in tree and all of this node's descendants. The tree tree could also be considered as a subtree of itself.<br> <br>Example 1:<br><br><br>Input: root = [3,4,5,1,2], subRoot = [4,1,2]<br>Output: true<br><br>Example 2:<br><br><br>Input: root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]<br>Output: false<br><br> <br>Constraints:<br><br>The number of nodes in the root tree is in the range [1, 2000].<br>The number of nodes in the subRoot tree is in the range [1, 1000].<br>-104 <= root.val <= 104<br>-104 <= subRoot.val <= 104<br><br></p>
                <a href=https://leetcode.com/problems/subtree-of-another-tree>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="c1"># Definition for a binary tree node.</span>
<span class="c1"># class TreeNode:</span>
<span class="c1">#     def __init__(self, val=0, left=None, right=None):</span>
<span class="c1">#         self.val = val</span>
<span class="c1">#         self.left = left</span>
<span class="c1">#         self.right = right</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">isSame</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">p</span> <span class="o">==</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">q</span><span class="o">==</span><span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">q</span><span class="o">==</span><span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">p</span><span class="o">==</span><span class="kc">None</span> <span class="ow">and</span> <span class="n">q</span><span class="o">!=</span><span class="kc">None</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        
        <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">val</span> <span class="o">!=</span><span class="n">q</span><span class="o">.</span><span class="n">val</span><span class="p">:</span><span class="k">return</span> <span class="kc">False</span>

        <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">isSame</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
        <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">isSame</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">left</span> <span class="ow">and</span> <span class="n">right</span>


    <span class="k">def</span> <span class="nf">isSubtree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">subRoot</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isSame</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">subRoot</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">isSubtree</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">subRoot</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">isSubtree</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">subRoot</span><span class="p">)</span>
        
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>60.Edit Distance</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>60.Edit Distance</h2>
                <p>Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2.<br>You have the following three operations permitted on a word:<br><br>Insert a character<br>Delete a character<br>Replace a character<br><br> <br>Example 1:<br><br>Input: word1 = "horse", word2 = "ros"<br>Output: 3<br>Explanation: <br>horse -> rorse (replace 'h' with 'r')<br>rorse -> rose (remove 'r')<br>rose -> ros (remove 'e')<br><br>Example 2:<br><br>Input: word1 = "intention", word2 = "execution"<br>Output: 5<br>Explanation: <br>intention -> inention (remove 't')<br>inention -> enention (replace 'i' with 'e')<br>enention -> exention (replace 'n' with 'x')<br>exention -> exection (replace 'n' with 'c')<br>exection -> execution (insert 'u')<br><br> <br>Constraints:<br><br>0 <= word1.length, word2.length <= 500<br>word1 and word2 consist of lowercase English letters.<br><br></p>
                <a href=https://leetcode.com/problems/edit-distance>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">min_dist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word1</span><span class="p">,</span> <span class="n">word2</span><span class="p">,</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        horse , ros</span>
<span class="sd">            orse, ros -&gt;</span>
<span class="sd">                rse, os -&gt; </span>
<span class="sd">                    se, s -&gt; 1</span>
<span class="sd">                        e,&quot;&quot; -&gt; 1</span>
<span class="sd">                    rse, s -&gt; 2</span>
<span class="sd">                        -&gt;se,&quot;&quot; 2</span>
<span class="sd">                        -&gt;rse, &quot;&quot; 3</span>
<span class="sd">                        -se,s 1</span>
<span class="sd">                    se, os</span>
<span class="sd">                orse, os</span>
<span class="sd">                orse, ros</span>
<span class="sd">            horse, os</span>
<span class="sd">            orse, ros</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">word1</span><span class="p">)</span><span class="o">-</span><span class="n">i</span>
        <span class="n">n2</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">word2</span><span class="p">)</span><span class="o">-</span><span class="n">j</span>

        <span class="k">if</span> <span class="n">n1</span><span class="o">==</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">n2</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">n1</span><span class="o">-</span><span class="n">n2</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">memo</span><span class="o">.</span><span class="n">get</span><span class="p">(</span> <span class="p">(</span><span class="n">n1</span><span class="p">,</span><span class="n">n2</span><span class="p">),</span> <span class="kc">None</span> <span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">memo</span><span class="p">[</span> <span class="p">(</span><span class="n">n1</span><span class="p">,</span><span class="n">n2</span><span class="p">)]</span>
        <span class="n">minm_dist</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">word1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">word2</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
            <span class="n">minm_dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_dist</span><span class="p">(</span><span class="n">word1</span><span class="p">,</span> <span class="n">word2</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># replace</span>
            <span class="n">replace</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_dist</span><span class="p">(</span><span class="n">word1</span><span class="p">,</span> <span class="n">word2</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># insert</span>
            <span class="n">insert</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_dist</span><span class="p">(</span><span class="n">word1</span><span class="p">,</span> <span class="n">word2</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># remove</span>
            <span class="n">remove</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_dist</span><span class="p">(</span><span class="n">word1</span><span class="p">,</span> <span class="n">word2</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
            <span class="n">minm_dist</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">replace</span><span class="p">,</span> <span class="n">insert</span><span class="p">,</span> <span class="n">remove</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">memo</span><span class="p">[</span> <span class="p">(</span><span class="n">n1</span><span class="p">,</span><span class="n">n2</span><span class="p">)]</span> <span class="o">=</span> <span class="n">minm_dist</span>
        <span class="k">return</span> <span class="n">minm_dist</span>
        
    <span class="k">def</span> <span class="nf">minDistance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word1</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">word2</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">memo</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_dist</span><span class="p">(</span><span class="n">word1</span><span class="p">,</span> <span class="n">word2</span><span class="p">,</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dist</span>
        
            
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>61.Move Zeroes</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>61.Move Zeroes</h2>
                <p>Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.<br>Note that you must do this in-place without making a copy of the array.<br> <br>Example 1:<br>Input: nums = [0,1,0,3,12]<br>Output: [1,3,12,0,0]<br>Example 2:<br>Input: nums = [0]<br>Output: [0]<br><br> <br>Constraints:<br><br>1 <= nums.length <= 104<br>-231 <= nums[i] <= 231 - 1<br><br> <br>Follow up: Could you minimize the total number of operations done?</p>
                <a href=https://leetcode.com/problems/move-zeroes>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">moveZeroes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Do not return anything, modify nums in-place instead.</span>
<span class="sd">        [0, 1, 0, 3, 5, 0, 7]</span>
<span class="sd">                  j     i</span>
<span class="sd">        [1, 3, 5, 7, 0, 0, 7]</span>
<span class="sd">               j. i</span>
<span class="sd">        [1, 2, 3, 0]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">j</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">j</span><span class="o">==-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">i</span>
            <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">!=</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">j</span><span class="o">!=-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">j</span><span class="o">+=</span><span class="mi">1</span>
            
        
        
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>62.Best Time to Buy and Sell Stock II</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>62.Best Time to Buy and Sell Stock II</h2>
                <p>You are given an integer array prices where prices[i] is the price of a given stock on the ith day.<br>On each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.<br>Find and return the maximum profit you can achieve.<br> <br>Example 1:<br><br>Input: prices = [7,1,5,3,6,4]<br>Output: 7<br>Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.<br>Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.<br>Total profit is 4 + 3 = 7.<br><br>Example 2:<br><br>Input: prices = [1,2,3,4,5]<br>Output: 4<br>Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.<br>Total profit is 4.<br><br>Example 3:<br><br>Input: prices = [7,6,4,3,1]<br>Output: 0<br>Explanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.<br><br> <br>Constraints:<br><br>1 <= prices.length <= 3 * 104<br>0 <= prices[i] <= 104<br><br></p>
                <a href=https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">maxProfit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">profit</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">prices</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">profit</span> <span class="o">+=</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">profit</span>
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>63.Vertical Order Traversal of a Binary Tree</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>63.Vertical Order Traversal of a Binary Tree</h2>
                <p>Given the root of a binary tree, calculate the vertical order traversal of the binary tree.<br>For each node at position (row, col), its left and right children will be at positions (row + 1, col - 1) and (row + 1, col + 1) respectively. The root of the tree is at (0, 0).<br>The vertical order traversal of a binary tree is a list of top-to-bottom orderings for each column index starting from the leftmost column and ending on the rightmost column. There may be multiple nodes in the same row and same column. In such a case, sort these nodes by their values.<br>Return the vertical order traversal of the binary tree.<br> <br>Example 1:<br><br><br>Input: root = [3,9,20,null,null,15,7]<br>Output: [[9],[3,15],[20],[7]]<br>Explanation:<br>Column -1: Only node 9 is in this column.<br>Column 0: Nodes 3 and 15 are in this column in that order from top to bottom.<br>Column 1: Only node 20 is in this column.<br>Column 2: Only node 7 is in this column.<br>Example 2:<br><br><br>Input: root = [1,2,3,4,5,6,7]<br>Output: [[4],[2],[1,5,6],[3],[7]]<br>Explanation:<br>Column -2: Only node 4 is in this column.<br>Column -1: Only node 2 is in this column.<br>Column 0: Nodes 1, 5, and 6 are in this column.<br>          1 is at the top, so it comes first.<br>          5 and 6 are at the same position (2, 0), so we order them by their value, 5 before 6.<br>Column 1: Only node 3 is in this column.<br>Column 2: Only node 7 is in this column.<br><br>Example 3:<br><br><br>Input: root = [1,2,3,4,6,5,7]<br>Output: [[4],[2],[1,5,6],[3],[7]]<br>Explanation:<br>This case is the exact same as example 2, but with nodes 5 and 6 swapped.<br>Note that the solution remains the same since 5 and 6 are in the same location and should be ordered by their values.<br><br> <br>Constraints:<br><br>The number of nodes in the tree is in the range [1, 1000].<br>0 <= Node.val <= 1000<br><br></p>
                <a href=https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="c1"># Definition for a binary tree node.</span>
<span class="c1"># class TreeNode:</span>
<span class="c1">#     def __init__(self, val=0, left=None, right=None):</span>
<span class="c1">#         self.val = val</span>
<span class="c1">#         self.left = left</span>
<span class="c1">#         self.right = right</span>
<span class="kn">import</span> <span class="nn">heapq</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">_helper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">height</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        
        <span class="k">if</span> <span class="n">pos</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos_dict</span><span class="p">:</span>
            <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pos_dict</span><span class="p">[</span><span class="n">pos</span><span class="p">],</span> <span class="p">(</span><span class="n">height</span><span class="p">,</span><span class="n">root</span><span class="o">.</span><span class="n">val</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pos_dict</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span> <span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">root</span><span class="o">.</span><span class="n">val</span><span class="p">)</span> <span class="p">]</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_helper</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">pos</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">height</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_helper</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">pos</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">height</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">def</span> <span class="nf">verticalTraversal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pos_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_helper</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="n">min_pos</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pos_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">max_pos</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pos_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">outputs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">min_pos</span><span class="p">,</span> <span class="n">max_pos</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos_dict</span><span class="p">:</span>
                <span class="n">elements</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">elements</span><span class="p">):</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">elements</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
                <span class="n">outputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">outputs</span>
        
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>64.Permutation in String</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>64.Permutation in String</h2>
                <p>Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.<br>In other words, return true if one of s1's permutations is the substring of s2.<br> <br>Example 1:<br><br>Input: s1 = "ab", s2 = "eidbaooo"<br>Output: true<br>Explanation: s2 contains one permutation of s1 ("ba").<br><br>Example 2:<br><br>Input: s1 = "ab", s2 = "eidboaoo"<br>Output: false<br><br> <br>Constraints:<br><br>1 <= s1.length, s2.length <= 104<br>s1 and s2 consist of lowercase English letters.<br><br></p>
                <a href=https://leetcode.com/problems/permutation-in-string>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">is_anagram</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">freq_map_s1</span><span class="p">,</span> <span class="n">freq_map_s2</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">freq_map_s1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">freq_map_s1</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">!=</span> <span class="n">freq_map_s2</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">def</span> <span class="nf">checkInclusion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s1</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">s2</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s2</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        
        <span class="n">freq_map_s1</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">freq_map_s2</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">s1</span><span class="p">):</span>
            <span class="n">freq_map_s1</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">+=</span><span class="mi">1</span>
        
        <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">end</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s2</span><span class="p">)):</span>
            <span class="n">freq_map_s2</span><span class="p">[</span><span class="n">s2</span><span class="p">[</span><span class="n">end</span><span class="p">]]</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="n">end</span><span class="o">-</span><span class="n">start</span><span class="o">+</span><span class="mi">1</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">s1</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_anagram</span><span class="p">(</span><span class="n">freq_map_s1</span><span class="p">,</span> <span class="n">freq_map_s2</span><span class="p">):</span>
                    <span class="k">return</span> <span class="kc">True</span>
                <span class="n">freq_map_s2</span><span class="p">[</span><span class="n">s2</span><span class="p">[</span><span class="n">start</span><span class="p">]]</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="n">start</span> <span class="o">+=</span><span class="mi">1</span>
        <span class="k">return</span> <span class="kc">False</span>
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>65.Roman to Integer</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>65.Roman to Integer</h2>
                <p>Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.<br><br>Symbol       Value<br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000<br>For example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.<br>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:<br><br>I can be placed before V (5) and X (10) to make 4 and 9. <br>X can be placed before L (50) and C (100) to make 40 and 90. <br>C can be placed before D (500) and M (1000) to make 400 and 900.<br><br>Given a roman numeral, convert it to an integer.<br> <br>Example 1:<br><br>Input: s = "III"<br>Output: 3<br>Explanation: III = 3.<br><br>Example 2:<br><br>Input: s = "LVIII"<br>Output: 58<br>Explanation: L = 50, V= 5, III = 3.<br><br>Example 3:<br><br>Input: s = "MCMXCIV"<br>Output: 1994<br>Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.<br><br> <br>Constraints:<br><br>1 <= s.length <= 15<br>s contains only the characters ('I', 'V', 'X', 'L', 'C', 'D', 'M').<br>It is guaranteed that s is a valid roman numeral in the range [1, 3999].<br><br></p>
                <a href=https://leetcode.com/problems/roman-to-integer>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="n">public</span><span class="p">:</span>
    <span class="nb">int</span> <span class="n">romanToInt</span><span class="p">(</span><span class="n">string</span> <span class="nb">str</span><span class="p">)</span> <span class="p">{</span>
        <span class="nb">map</span><span class="o">&lt;</span><span class="n">char</span><span class="p">,</span><span class="nb">int</span><span class="o">&gt;</span> <span class="n">symbol_map</span> <span class="o">=</span> <span class="p">{</span>
            <span class="p">{</span><span class="s1">&#39;I&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span>
            <span class="p">{</span><span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">},</span>
            <span class="p">{</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="mi">10</span><span class="p">},</span>
            <span class="p">{</span><span class="s1">&#39;L&#39;</span><span class="p">,</span> <span class="mi">50</span><span class="p">},</span>
            <span class="p">{</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="mi">100</span><span class="p">},</span>
            <span class="p">{</span><span class="s1">&#39;D&#39;</span><span class="p">,</span> <span class="mi">500</span><span class="p">},</span>
            <span class="p">{</span><span class="s1">&#39;M&#39;</span><span class="p">,</span> <span class="mi">1000</span><span class="p">}</span>
        <span class="p">};</span>
        <span class="nb">int</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span> <span class="nb">str</span><span class="o">.</span><span class="n">length</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="nb">int</span> <span class="n">c_val</span> <span class="o">=</span> <span class="n">symbol_map</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="nb">str</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="nb">int</span> <span class="n">n_val</span> <span class="o">=</span> <span class="n">c_val</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="nb">str</span><span class="o">.</span><span class="n">length</span><span class="p">())</span><span class="n">n_val</span> <span class="o">=</span> <span class="n">symbol_map</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="nb">str</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]);</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">n_val</span> <span class="o">&gt;</span> <span class="n">c_val</span><span class="p">){</span>
                <span class="n">c_val</span> <span class="o">=</span> <span class="n">n_val</span><span class="o">-</span><span class="n">c_val</span><span class="p">;</span>
                <span class="n">i</span> <span class="o">+=</span><span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">value</span> <span class="o">+=</span> <span class="n">c_val</span><span class="p">;</span> 
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">value</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>66.Lowest Common Ancestor of a Binary Search Tree</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>66.Lowest Common Ancestor of a Binary Search Tree</h2>
                <p>Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST.<br>According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”<br> <br>Example 1:<br><br><br>Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8<br>Output: 6<br>Explanation: The LCA of nodes 2 and 8 is 6.<br><br>Example 2:<br><br><br>Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4<br>Output: 2<br>Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.<br><br>Example 3:<br><br>Input: root = [2,1], p = 2, q = 1<br>Output: 2<br><br> <br>Constraints:<br><br>The number of nodes in the tree is in the range [2, 105].<br>-109 <= Node.val <= 109<br>All Node.val are unique.<br>p != q<br>p and q will exist in the BST.<br><br></p>
                <a href=https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="c1"># Definition for a binary tree node.</span>
<span class="c1"># class TreeNode:</span>
<span class="c1">#     def __init__(self, x):</span>
<span class="c1">#         self.val = x</span>
<span class="c1">#         self.left = None</span>
<span class="c1">#         self.right = None</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">lca</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">node1</span><span class="p">,</span> <span class="n">node2</span><span class="p">):</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">node1</span> <span class="o">==</span> <span class="n">root</span> <span class="ow">or</span> <span class="n">node2</span> <span class="o">==</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">root</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">left</span> <span class="o">==</span> <span class="n">node1</span> <span class="ow">and</span> <span class="n">root</span><span class="o">.</span><span class="n">right</span> <span class="o">==</span> <span class="n">node2</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">right</span> <span class="o">==</span> <span class="n">node1</span> <span class="ow">and</span> <span class="n">root</span><span class="o">.</span><span class="n">left</span> <span class="o">==</span> <span class="n">node2</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">root</span>

        <span class="n">leftlca</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lca</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">node1</span><span class="p">,</span> <span class="n">node2</span><span class="p">)</span>
        <span class="n">rightlca</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lca</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">node1</span><span class="p">,</span> <span class="n">node2</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">leftlca</span> <span class="ow">and</span> <span class="n">rightlca</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">root</span>
        <span class="k">elif</span> <span class="n">leftlca</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">leftlca</span>

        <span class="k">return</span> <span class="n">rightlca</span>
    <span class="k">def</span> <span class="nf">lowestCommonAncestor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="s1">&#39;TreeNode&#39;</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="s1">&#39;TreeNode&#39;</span><span class="p">,</span> <span class="n">q</span><span class="p">:</span> <span class="s1">&#39;TreeNode&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;TreeNode&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">lca</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>67.Contains Duplicate</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>67.Contains Duplicate</h2>
                <p>Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.<br> <br>Example 1:<br>Input: nums = [1,2,3,1]<br>Output: true<br>Example 2:<br>Input: nums = [1,2,3,4]<br>Output: false<br>Example 3:<br>Input: nums = [1,1,1,3,3,4,3,2,4,2]<br>Output: true<br><br> <br>Constraints:<br><br>1 <= nums.length <= 105<br>-109 <= nums[i] <= 109<br><br></p>
                <a href=https://leetcode.com/problems/contains-duplicate>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">containsDuplicate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">nums_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">nums_set</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="n">nums_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">False</span>
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>68.One Edit Distance</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>68.One Edit Distance</h2>
                <p></p>
                <a href=https://leetcode.com/problems/one-edit-distance>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">dist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">d</span><span class="o">==</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">s</span><span class="o">==</span><span class="n">t</span> <span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">d</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="ow">and</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">status</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">d</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">status</span><span class="p">:</span> <span class="k">return</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">d</span><span class="o">&lt;</span><span class="mi">1</span> <span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
                <span class="n">replace</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># replace</span>
                <span class="k">if</span> <span class="n">replace</span> <span class="p">:</span> <span class="k">return</span> <span class="kc">True</span>
            
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
                <span class="n">remove</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">t</span><span class="p">,</span> <span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">remove</span><span class="p">:</span> <span class="k">return</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
                <span class="n">insert</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># insert</span>
                <span class="k">if</span> <span class="n">insert</span><span class="p">:</span><span class="k">return</span> <span class="kc">True</span>
            
            
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">def</span> <span class="nf">isOneEditDistance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">status</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">d</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">status</span>
        
        
        
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>69.Find Minimum in Rotated Sorted Array</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>69.Find Minimum in Rotated Sorted Array</h2>
                <p>Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:<br><br>[4,5,6,7,0,1,2] if it was rotated 4 times.<br>[0,1,2,4,5,6,7] if it was rotated 7 times.<br><br>Notice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]].<br>Given the sorted rotated array nums of unique elements, return the minimum element of this array.<br>You must write an algorithm that runs in O(log n) time.<br> <br>Example 1:<br><br>Input: nums = [3,4,5,1,2]<br>Output: 1<br>Explanation: The original array was [1,2,3,4,5] rotated 3 times.<br><br>Example 2:<br><br>Input: nums = [4,5,6,7,0,1,2]<br>Output: 0<br>Explanation: The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.<br><br>Example 3:<br><br>Input: nums = [11,13,15,17]<br>Output: 11<br>Explanation: The original array was [11,13,15,17] and it was rotated 4 times. <br><br> <br>Constraints:<br><br>n == nums.length<br>1 <= n <= 5000<br>-5000 <= nums[i] <= 5000<br>All the integers of nums are unique.<br>nums is sorted and rotated between 1 and n times.<br><br></p>
                <a href=https://leetcode.com/problems/find-minimum-in-rotated-sorted-array>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">findMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        4 6 7 1 2 3</span>
<span class="sd">        7 1 2 3</span>

<span class="sd">        0 1</span>
<span class="sd">        l =1 </span>
<span class="sd">        r =1 </span>
<span class="sd">        m = 1</span>

<span class="sd">        4 0 1</span>
<span class="sd">        if middle &lt; l and middle &lt; r:return </span>
<span class="sd">        [11,13,15,17] 4 </span>
<span class="sd">        m = 2</span>

<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
        <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span> 
        <span class="n">r</span> <span class="o">=</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span>

        <span class="k">while</span> <span class="n">l</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span><span class="o">+</span><span class="n">r</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>

            <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">nums</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">[(</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">n</span><span class="p">]:</span>
                <span class="k">return</span> <span class="n">nums</span><span class="p">[</span><span class="n">m</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">nums</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">r</span><span class="p">]:</span>
                <span class="n">l</span> <span class="o">=</span> <span class="n">m</span><span class="o">+</span><span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">r</span><span class="o">=</span> <span class="n">m</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">return</span> <span class="n">nums</span><span class="p">[</span><span class="n">m</span><span class="p">]</span>
        
        
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>70.Product of Array Except Self</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>70.Product of Array Except Self</h2>
                <p>Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].<br>The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.<br>You must write an algorithm that runs in O(n) time and without using the division operation.<br> <br>Example 1:<br>Input: nums = [1,2,3,4]<br>Output: [24,12,8,6]<br>Example 2:<br>Input: nums = [-1,1,0,-3,3]<br>Output: [0,0,9,0,0]<br><br> <br>Constraints:<br><br>2 <= nums.length <= 105<br>-30 <= nums[i] <= 30<br>The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.<br><br> <br>Follow up: Can you solve the problem in O(1) extra space complexity? (The output array does not count as extra space for space complexity analysis.)<br></p>
                <a href=https://leetcode.com/problems/product-of-array-except-self>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">productExceptSelf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="n">output</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
        <span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
            <span class="n">output</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        
        <span class="n">right_prod</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">left_prod</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span>
            <span class="n">output</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">left_prod</span> <span class="o">*</span> <span class="n">right_prod</span>
            <span class="n">right_prod</span> <span class="o">*=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">output</span>
        
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>71.Shortest Path Visiting All Nodes</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>71.Shortest Path Visiting All Nodes</h2>
                <p>You have an undirected, connected graph of n nodes labeled from 0 to n - 1. You are given an array graph where graph[i] is a list of all the nodes connected with node i by an edge.<br>Return the length of the shortest path that visits every node. You may start and stop at any node, you may revisit nodes multiple times, and you may reuse edges.<br> <br>Example 1:<br><br><br>Input: graph = [[1,2,3],[0],[0],[0]]<br>Output: 4<br>Explanation: One possible path is [1,0,2,0,3]<br><br>Example 2:<br><br><br>Input: graph = [[1],[0,2,4],[1,3,4],[2],[1,2]]<br>Output: 4<br>Explanation: One possible path is [0,1,4,2,3]<br><br> <br>Constraints:<br><br>n == graph.length<br>1 <= n <= 12<br>0 <= graph[i].length < n<br>graph[i] does not contain i.<br>If graph[a] contains b, then graph[b] contains a.<br>The input graph is always connected.<br><br></p>
                <a href=https://leetcode.com/problems/shortest-path-visiting-all-nodes>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">path_length</span> <span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="p">[]):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">path</span><span class="p">))</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shortest_path</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">,</span> <span class="n">path_length</span><span class="p">)</span>
            <span class="c1">#print (path, path_length, visited)</span>
        <span class="k">if</span> <span class="n">path_length</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">:</span>
            <span class="k">return</span> 
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
            <span class="c1"># if (u,v) not in visited:</span>
            <span class="k">if</span> <span class="n">visited</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># visited.add( (u, v))</span>
                <span class="n">visited</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="c1"># path.add(v)</span>
                <span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dfs</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">path_length</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>
                <span class="n">path</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="c1"># visited.remove( (u,v))</span>
                <span class="n">visited</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">shortestPathLength1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shortest_path</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="p">[</span> <span class="p">[</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="p">)):</span>
            <span class="c1">#print (i,&quot;___\n\n&quot;)</span>
            <span class="c1">#visited = set()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dfs</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">shortest_path</span>
    
    <span class="k">def</span> <span class="nf">shortestPathLength</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
        <span class="n">all_visited</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">n</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([(</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)])</span>
        <span class="n">seen</span> <span class="o">=</span> <span class="p">{(</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)}</span>

        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">node</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">distance</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">visited</span> <span class="o">==</span> <span class="n">all_visited</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">distance</span>
            <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
                <span class="n">new_visited</span> <span class="o">=</span> <span class="n">visited</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">neighbor</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">neighbor</span><span class="p">,</span> <span class="n">new_visited</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
                    <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">neighbor</span><span class="p">,</span> <span class="n">new_visited</span><span class="p">,</span> <span class="n">distance</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                    <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">neighbor</span><span class="p">,</span> <span class="n">new_visited</span><span class="p">))</span>

        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
        
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>72.Reverse Bits</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>72.Reverse Bits</h2>
                <p>Reverse bits of a given 32 bits unsigned integer.<br>Note:<br><br>Note that in some languages, such as Java, there is no unsigned integer type. In this case, both input and output will be given as a signed integer type. They should not affect your implementation, as the integer's internal binary representation is the same, whether it is signed or unsigned.<br>In Java, the compiler represents the signed integers using 2's complement notation. Therefore, in Example 2 above, the input represents the signed integer -3 and the output represents the signed integer -1073741825.<br><br> <br>Example 1:<br><br>Input: n = 00000010100101000001111010011100<br>Output:    964176192 (00111001011110000010100101000000)<br>Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000.<br><br>Example 2:<br><br>Input: n = 11111111111111111111111111111101<br>Output:   3221225471 (10111111111111111111111111111111)<br>Explanation: The input binary string 11111111111111111111111111111101 represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is 10111111111111111111111111111111.<br><br> <br>Constraints:<br><br>The input must be a binary string of length 32<br><br> <br>Follow up: If this function is called many times, how would you optimize it?<br></p>
                <a href=https://leetcode.com/problems/reverse-bits>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">set_bit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">val</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">|</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span><span class="n">i</span> <span class="p">))</span>
        <span class="k">return</span> <span class="n">n</span>
    <span class="k">def</span> <span class="nf">reverseBits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">output</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">):</span>
            <span class="n">left_bit</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">31</span><span class="o">-</span><span class="n">i</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">n</span> 
            <span class="n">right_bit</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">n</span>

            <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_bit</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">left_bit</span><span class="p">)</span>
            <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_bit</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="p">(</span><span class="mi">31</span><span class="o">-</span><span class="n">i</span><span class="p">),</span>  <span class="n">right_bit</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">n</span>
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>73.Maximum Subarray</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>73.Maximum Subarray</h2>
                <p>Given an integer array nums, find the subarray with the largest sum, and return its sum.<br> <br>Example 1:<br><br>Input: nums = [-2,1,-3,4,-1,2,1,-5,4]<br>Output: 6<br>Explanation: The subarray [4,-1,2,1] has the largest sum 6.<br><br>Example 2:<br><br>Input: nums = [1]<br>Output: 1<br>Explanation: The subarray [1] has the largest sum 1.<br><br>Example 3:<br><br>Input: nums = [5,4,-1,7,8]<br>Output: 23<br>Explanation: The subarray [5,4,-1,7,8] has the largest sum 23.<br><br> <br>Constraints:<br><br>1 <= nums.length <= 105<br>-104 <= nums[i] <= 104<br><br> <br>Follow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.<br></p>
                <a href=https://leetcode.com/problems/maximum-subarray>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">maxSubArray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">c_sum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">max_sum</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;-inf&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
            <span class="n">c_sum</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">c_sum</span><span class="o">+</span><span class="n">num</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span>
            <span class="n">max_sum</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_sum</span><span class="p">,</span> <span class="n">c_sum</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">max_sum</span>
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>74.Longest Substring with At Most K Distinct Characters</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>74.Longest Substring with At Most K Distinct Characters</h2>
                <p></p>
                <a href=https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">lengthOfLongestSubstringKDistinct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        aa = &gt; </span>
<span class="sd">        a :1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">k</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span><span class="k">return</span> <span class="mi">0</span>
        <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">char_freq</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">max_len</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">end</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)):</span>
            <span class="n">char_freq</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">end</span><span class="p">]]</span> <span class="o">=</span> <span class="n">char_freq</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">end</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">char_freq</span><span class="p">)</span> <span class="o">&gt;</span><span class="n">k</span><span class="p">:</span>
                <span class="n">char_freq</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">start</span><span class="p">]]</span> <span class="o">-=</span><span class="mi">1</span>
                <span class="k">if</span> <span class="n">char_freq</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">start</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">:</span>
                    <span class="k">del</span> <span class="n">char_freq</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">start</span><span class="p">]]</span>
                <span class="n">start</span> <span class="o">+=</span><span class="mi">1</span>
            <span class="n">max_len</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_len</span><span class="p">,</span> <span class="n">end</span><span class="o">-</span><span class="n">start</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">max_len</span>
                
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>75.Kth Smallest Element in a BST</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>75.Kth Smallest Element in a BST</h2>
                <p>Given the root of a binary search tree, and an integer k, return the kth smallest value (1-indexed) of all the values of the nodes in the tree.<br> <br>Example 1:<br><br><br>Input: root = [3,1,4,null,2], k = 1<br>Output: 1<br><br>Example 2:<br><br><br>Input: root = [5,3,6,2,4,null,null,1], k = 3<br>Output: 3<br><br> <br>Constraints:<br><br>The number of nodes in the tree is n.<br>1 <= k <= n <= 104<br>0 <= Node.val <= 104<br><br> <br>Follow up: If the BST is modified often (i.e., we can do insert and delete operations) and you need to find the kth smallest frequently, how would you optimize?<br></p>
                <a href=https://leetcode.com/problems/kth-smallest-element-in-a-bst>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="c1"># Definition for a binary tree node.</span>
<span class="c1"># class TreeNode:</span>
<span class="c1">#     def __init__(self, val=0, left=None, right=None):</span>
<span class="c1">#         self.val = val</span>
<span class="c1">#         self.left = left</span>
<span class="c1">#         self.right = right</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">_kth_small</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span><span class="n">k</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
        
        <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kth_small</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">left</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">left</span>
        <span class="c1">#print(root.val, self.count, left)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">+=</span><span class="mi">1</span> 
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">==</span> <span class="n">k</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">result</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">val</span>
            <span class="k">return</span> <span class="n">root</span><span class="o">.</span><span class="n">val</span>
        <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kth_small</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">right</span>
        
    <span class="k">def</span> <span class="nf">kthSmallest</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">result</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kth_small</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">k</span> <span class="p">)</span>
        <span class="k">return</span> <span class="n">val</span>
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>76.Continuous Subarray Sum</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>76.Continuous Subarray Sum</h2>
                <p>Given an integer array nums and an integer k, return true if nums has a good subarray or false otherwise.<br>A good subarray is a subarray where:<br><br>its length is at least two, and<br>the sum of the elements of the subarray is a multiple of k.<br><br>Note that:<br><br>A subarray is a contiguous part of the array.<br>An integer x is a multiple of k if there exists an integer n such that x = n * k. 0 is always a multiple of k.<br><br> <br>Example 1:<br><br>Input: nums = [23,2,4,6,7], k = 6<br>Output: true<br>Explanation: [2, 4] is a continuous subarray of size 2 whose elements sum up to 6.<br><br>Example 2:<br><br>Input: nums = [23,2,6,4,7], k = 6<br>Output: true<br>Explanation: [23, 2, 6, 4, 7] is an continuous subarray of size 5 whose elements sum up to 42.<br>42 is a multiple of 6 because 42 = 7 * 6 and 7 is an integer.<br><br>Example 3:<br><br>Input: nums = [23,2,6,4,7], k = 13<br>Output: false<br><br> <br>Constraints:<br><br>1 <= nums.length <= 105<br>0 <= nums[i] <= 109<br>0 <= sum(nums[i]) <= 231 - 1<br>1 <= k <= 231 - 1<br><br></p>
                <a href=https://leetcode.com/problems/continuous-subarray-sum>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">checkSubarraySum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        [23, 2, 4, 6, 7]</span>
<span class="sd">        </span>
<span class="sd">        [23, 25, 29, 35,42]</span>
<span class="sd">        [5.  1.  5.  5. 7.]</span>

<span class="sd">        [23, 2,4,6,6]</span>
<span class="sd">        [23 25 29, 35, 41]</span>
<span class="sd">         2. 4. 1.  0.  6</span>

<span class="sd">        [1, 0]</span>
<span class="sd">        1 1</span>
<span class="sd">        1 1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">prefix_sum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
        <span class="n">prefix_mod</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">prefix_mod</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">end</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
            <span class="n">prefix_sum</span> <span class="o">+=</span> <span class="n">nums</span><span class="p">[</span><span class="n">end</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">prefix_sum</span> <span class="o">%</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">prefix_mod</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">end</span><span class="o">-</span><span class="n">prefix_mod</span><span class="p">[</span><span class="n">prefix_sum</span> <span class="o">%</span> <span class="n">k</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">prefix_mod</span><span class="p">[</span><span class="n">prefix_sum</span><span class="o">%</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">end</span>
        <span class="k">return</span> <span class="kc">False</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">11   21. 31. </span>
<span class="sd">1.   1.  1</span>


<span class="sd">x%k ==  (x+y) %k =&gt; x%k + y % k</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>77.Maximum Depth of Binary Tree</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>77.Maximum Depth of Binary Tree</h2>
                <p>Given the root of a binary tree, return its maximum depth.<br>A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.<br> <br>Example 1:<br><br><br>Input: root = [3,9,20,null,null,15,7]<br>Output: 3<br><br>Example 2:<br><br>Input: root = [1,null,2]<br>Output: 2<br><br> <br>Constraints:<br><br>The number of nodes in the tree is in the range [0, 104].<br>-100 <= Node.val <= 100<br><br></p>
                <a href=https://leetcode.com/problems/maximum-depth-of-binary-tree>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="c1"># Definition for a binary tree node.</span>
<span class="c1"># class TreeNode:</span>
<span class="c1">#     def __init__(self, val=0, left=None, right=None):</span>
<span class="c1">#         self.val = val</span>
<span class="c1">#         self.left = left</span>
<span class="c1">#         self.right = right</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">maxDepth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        
        <span class="n">left_d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxDepth</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
        <span class="n">right_d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxDepth</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
        <span class="n">depth</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">left_d</span><span class="p">,</span> <span class="n">right_d</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> 

        <span class="k">return</span> <span class="n">depth</span>
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>78.Group Anagrams</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>78.Group Anagrams</h2>
                <p>Given an array of strings strs, group the anagrams together. You can return the answer in any order.<br>An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.<br> <br>Example 1:<br>Input: strs = ["eat","tea","tan","ate","nat","bat"]<br>Output: [["bat"],["nat","tan"],["ate","eat","tea"]]<br>Example 2:<br>Input: strs = [""]<br>Output: [[""]]<br>Example 3:<br>Input: strs = ["a"]<br>Output: [["a"]]<br><br> <br>Constraints:<br><br>1 <= strs.length <= 104<br>0 <= strs[i].length <= 100<br>strs[i] consists of lowercase English letters.<br><br></p>
                <a href=https://leetcode.com/problems/group-anagrams>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">groupAnagrams</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">strs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
        <span class="n">output</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">string</span> <span class="ow">in</span> <span class="n">strs</span><span class="p">:</span>
            <span class="n">string_sort</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">string</span><span class="p">))</span>
            <span class="n">out_group</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">string_sort</span><span class="p">,</span> <span class="p">[])</span>
            <span class="n">out_group</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
            <span class="n">output</span><span class="p">[</span><span class="n">string_sort</span><span class="p">]</span> <span class="o">=</span> <span class="n">out_group</span>
        
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>79.Shortest Path in Binary Matrix</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>79.Shortest Path in Binary Matrix</h2>
                <p>Given an n x n binary matrix grid, return the length of the shortest clear path in the matrix. If there is no clear path, return -1.<br>A clear path in a binary matrix is a path from the top-left cell (i.e., (0, 0)) to the bottom-right cell (i.e., (n - 1, n - 1)) such that:<br><br>All the visited cells of the path are 0.<br>All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).<br><br>The length of a clear path is the number of visited cells of this path.<br> <br>Example 1:<br><br><br>Input: grid = [[0,1],[1,0]]<br>Output: 2<br><br>Example 2:<br><br><br>Input: grid = [[0,0,0],[1,1,0],[1,1,0]]<br>Output: 4<br><br>Example 3:<br><br>Input: grid = [[1,0,0],[1,1,0],[1,1,0]]<br>Output: -1<br><br> <br>Constraints:<br><br>n == grid.length<br>n == grid[i].length<br>1 <= n <= 100<br>grid[i][j] is 0 or 1<br><br></p>
                <a href=https://leetcode.com/problems/shortest-path-in-binary-matrix>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">shortestPathBinaryMatrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        [[0,0,0],</span>
<span class="sd">         [1,0,0],</span>
<span class="sd">         [1,1,0]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span> <span class="c1"># [ 2,(1.1), | 2,(1,0),  3,(0,2),  3,(1,2), 3,(1,1)]</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">target</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="n">start</span><span class="p">))</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>

        <span class="n">neighbours</span> <span class="o">=</span> <span class="p">[(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> 
                      <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)]</span>

        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
            <span class="n">dist</span><span class="p">,</span> <span class="n">c_node</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="c1">#print (dist, c_node)</span>
            <span class="k">if</span> <span class="n">c_node</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">dist</span>
            <span class="n">r</span><span class="p">,</span><span class="n">c</span> <span class="o">=</span> <span class="n">c_node</span>
            <span class="k">for</span> <span class="n">dr</span><span class="p">,</span> <span class="n">dc</span> <span class="ow">in</span> <span class="n">neighbours</span><span class="p">:</span>
                <span class="n">r1</span><span class="p">,</span> <span class="n">c1</span> <span class="o">=</span> <span class="n">r</span><span class="o">+</span><span class="n">dr</span><span class="p">,</span> <span class="n">c</span><span class="o">+</span><span class="n">dc</span>
                
                <span class="k">if</span> <span class="mi">0</span><span class="o">&lt;=</span><span class="n">r1</span><span class="o">&lt;</span><span class="n">n</span> <span class="ow">and</span> <span class="mi">0</span><span class="o">&lt;=</span><span class="n">c1</span><span class="o">&lt;</span><span class="n">m</span> <span class="ow">and</span> <span class="p">(</span> <span class="p">(</span><span class="n">r1</span><span class="p">,</span><span class="n">c1</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span> <span class="p">)</span> \
                    <span class="ow">and</span> <span class="n">grid</span><span class="p">[</span><span class="n">r1</span><span class="p">][</span><span class="n">c1</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                    <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span> <span class="p">(</span><span class="n">r1</span><span class="p">,</span><span class="n">c1</span><span class="p">)</span> <span class="p">)</span>
                    <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">(</span><span class="n">dist</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">r1</span><span class="p">,</span><span class="n">c1</span><span class="p">)))</span>

        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>80.Subarray Sum Equals K</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>80.Subarray Sum Equals K</h2>
                <p>Given an array of integers nums and an integer k, return the total number of subarrays whose sum equals to k.<br>A subarray is a contiguous non-empty sequence of elements within an array.<br> <br>Example 1:<br>Input: nums = [1,1,1], k = 2<br>Output: 2<br>Example 2:<br>Input: nums = [1,2,3], k = 3<br>Output: 2<br><br> <br>Constraints:<br><br>1 <= nums.length <= 2 * 104<br>-1000 <= nums[i] <= 1000<br>-107 <= k <= 107<br><br></p>
                <a href=https://leetcode.com/problems/subarray-sum-equals-k>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">subarraySum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">sub_sum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
        
        <span class="c1"># # print (prefix_sum)</span>
        <span class="c1"># for i in range(n):</span>
        <span class="c1">#     sub_arr_sum = 0</span>
        <span class="c1">#     for j in range(i, n):</span>
        <span class="c1">#         sub_arr_sum += nums[j]</span>
        <span class="c1">#         if sub_arr_sum == k:</span>
        <span class="c1">#             count +=1</span>
        <span class="n">prefix_sum</span> <span class="o">=</span> <span class="mi">0</span> 
        <span class="n">prefix_dict</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
            <span class="n">prefix_sum</span> <span class="o">+=</span> <span class="n">num</span>

            <span class="n">compl</span> <span class="o">=</span> <span class="n">prefix_sum</span> <span class="o">-</span> <span class="n">k</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="n">prefix_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">compl</span><span class="p">,</span> <span class="mi">0</span> <span class="p">)</span>
            <span class="n">prefix_dict</span><span class="p">[</span><span class="n">prefix_sum</span><span class="p">]</span> <span class="o">=</span> <span class="n">prefix_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">prefix_sum</span><span class="p">,</span> <span class="mi">0</span> <span class="p">)</span> <span class="o">+</span><span class="mi">1</span>
        <span class="k">return</span> <span class="n">count</span>
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>81.Score of a String</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>81.Score of a String</h2>
                <p>You are given a string s. The score of a string is defined as the sum of the absolute difference between the ASCII values of adjacent characters.<br>Return the score of s.<br> <br>Example 1:<br><br>Input: s = "hello"<br>Output: 13<br>Explanation:<br>The ASCII values of the characters in s are: 'h' = 104, 'e' = 101, 'l' = 108, 'o' = 111. So, the score of s would be |104 - 101| + |101 - 108| + |108 - 108| + |108 - 111| = 3 + 7 + 0 + 3 = 13.<br><br>Example 2:<br><br>Input: s = "zaz"<br>Output: 50<br>Explanation:<br>The ASCII values of the characters in s are: 'z' = 122, 'a' = 97. So, the score of s would be |122 - 97| + |97 - 122| = 25 + 25 = 50.<br><br> <br>Constraints:<br><br>2 <= s.length <= 100<br>s consists only of lowercase English letters.<br><br></p>
                <a href=https://leetcode.com/problems/score-of-a-string>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="n">public</span><span class="p">:</span>
    <span class="nb">int</span> <span class="n">scoreOfString</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
        <span class="nb">int</span> <span class="n">score</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="nb">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">s</span><span class="o">.</span><span class="n">length</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="n">score</span> <span class="o">+=</span> <span class="nb">abs</span><span class="p">(</span><span class="nb">int</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]));</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">score</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>82.Invert Binary Tree</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>82.Invert Binary Tree</h2>
                <p>Given the root of a binary tree, invert the tree, and return its root.<br> <br>Example 1:<br><br><br>Input: root = [4,2,7,1,3,6,9]<br>Output: [4,7,2,9,6,3,1]<br><br>Example 2:<br><br><br>Input: root = [2,1,3]<br>Output: [2,3,1]<br><br>Example 3:<br><br>Input: root = []<br>Output: []<br><br> <br>Constraints:<br><br>The number of nodes in the tree is in the range [0, 100].<br>-100 <= Node.val <= 100<br><br></p>
                <a href=https://leetcode.com/problems/invert-binary-tree>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="c1"># Definition for a binary tree node.</span>
<span class="c1"># class TreeNode:</span>
<span class="c1">#     def __init__(self, val=0, left=None, right=None):</span>
<span class="c1">#         self.val = val</span>
<span class="c1">#         self.left = left</span>
<span class="c1">#         self.right = right</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">invertTree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        
        <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">invertTree</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
        <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">invertTree</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
        <span class="n">root</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
        <span class="n">root</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="k">return</span> <span class="n">root</span>
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>83.Set Matrix Zeroes</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>83.Set Matrix Zeroes</h2>
                <p>Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0's.<br>You must do it in place.<br> <br>Example 1:<br><br><br>Input: matrix = [[1,1,1],[1,0,1],[1,1,1]]<br>Output: [[1,0,1],[0,0,0],[1,0,1]]<br><br>Example 2:<br><br><br>Input: matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]<br>Output: [[0,0,0,0],[0,4,5,0],[0,3,1,0]]<br><br> <br>Constraints:<br><br>m == matrix.length<br>n == matrix[0].length<br>1 <= m, n <= 200<br>-231 <= matrix[i][j] <= 231 - 1<br><br> <br>Follow up:<br><br>A straightforward solution using O(mn) space is probably a bad idea.<br>A simple improvement uses O(m + n) space, but still not the best solution.<br>Could you devise a constant space solution?<br><br></p>
                <a href=https://leetcode.com/problems/set-matrix-zeroes>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">setZeroes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">matrix</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Do not return anything, modify matrix in-place instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ROWS</span><span class="p">,</span> <span class="n">COLS</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">matrix</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="n">first_row</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">first_col</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">ROWS</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">COLS</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">matrix</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">r</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                        <span class="n">first_row</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">if</span> <span class="n">c</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                        <span class="n">first_col</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">if</span> <span class="n">r</span><span class="o">!=</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">c</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
                        <span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="n">matrix</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">ROWS</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">COLS</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">matrix</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">matrix</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        
        <span class="k">if</span> <span class="n">first_row</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">:</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">COLS</span><span class="p">):</span>
                <span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">first_col</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">:</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ROWS</span><span class="p">):</span>
                <span class="n">matrix</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">matrix</span>
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>84.Valid Palindrome II</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>84.Valid Palindrome II</h2>
                <p>Given a string s, return true if the s can be palindrome after deleting at most one character from it.<br> <br>Example 1:<br><br>Input: s = "aba"<br>Output: true<br><br>Example 2:<br><br>Input: s = "abca"<br>Output: true<br>Explanation: You could delete the character 'c'.<br><br>Example 3:<br><br>Input: s = "abc"<br>Output: false<br><br> <br>Constraints:<br><br>1 <= s.length <= 105<br>s consists of lowercase English letters.<br><br></p>
                <a href=https://leetcode.com/problems/valid-palindrome-ii>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">validPalindrome</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        acdcba</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">check_palind</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
            <span class="k">while</span> <span class="n">l</span><span class="o">&lt;</span><span class="n">r</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="n">r</span><span class="p">]:</span>
                    <span class="n">l</span><span class="o">+=</span><span class="mi">1</span>
                    <span class="n">r</span><span class="o">-=</span><span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
            <span class="k">return</span> <span class="kc">True</span>
                    
        <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">r</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
        <span class="n">deletes</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">l</span><span class="o">&lt;</span><span class="n">r</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">!=</span> <span class="n">s</span><span class="p">[</span><span class="n">r</span><span class="p">]:</span>
                <span class="k">return</span> <span class="n">check_palind</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="ow">or</span> <span class="n">check_palind</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">l</span><span class="o">+=</span><span class="mi">1</span>
            <span class="n">r</span><span class="o">-=</span><span class="mi">1</span>
            
        <span class="k">return</span> <span class="kc">True</span>
        
                
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>85.Remove Nth Node From End of List</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>85.Remove Nth Node From End of List</h2>
                <p>Given the head of a linked list, remove the nth node from the end of the list and return its head.<br> <br>Example 1:<br><br><br>Input: head = [1,2,3,4,5], n = 2<br>Output: [1,2,3,5]<br><br>Example 2:<br><br>Input: head = [1], n = 1<br>Output: []<br><br>Example 3:<br><br>Input: head = [1,2], n = 1<br>Output: [1]<br><br> <br>Constraints:<br><br>The number of nodes in the list is sz.<br>1 <= sz <= 30<br>0 <= Node.val <= 100<br>1 <= n <= sz<br><br> <br>Follow up: Could you do this in one pass?<br></p>
                <a href=https://leetcode.com/problems/remove-nth-node-from-end-of-list>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="c1"># Definition for singly-linked list.</span>
<span class="c1"># class ListNode:</span>
<span class="c1">#     def __init__(self, val=0, next=None):</span>
<span class="c1">#         self.val = val</span>
<span class="c1">#         self.next = next</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">removeNthFromEnd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">head</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">],</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        1 2 3 4 5</span>
<span class="sd">        p1 = 1  1  2. 3</span>
<span class="sd">        p2 = 1, 3, 4, 5</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ptr1</span> <span class="o">=</span> <span class="n">head</span>
        <span class="n">ptr2</span> <span class="o">=</span> <span class="n">head</span>

        <span class="c1"># move the ptr 2 to nth node</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">ptr2</span> <span class="o">=</span> <span class="n">ptr2</span><span class="o">.</span><span class="n">next</span>
        
        <span class="k">if</span> <span class="n">ptr2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">head</span>
            <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="n">next</span>
            <span class="k">del</span> <span class="n">node</span>

        <span class="k">while</span> <span class="n">ptr2</span> <span class="ow">and</span> <span class="n">ptr2</span><span class="o">.</span><span class="n">next</span><span class="p">:</span>
            <span class="n">ptr2</span> <span class="o">=</span> <span class="n">ptr2</span><span class="o">.</span><span class="n">next</span>
            <span class="n">ptr1</span> <span class="o">=</span> <span class="n">ptr1</span><span class="o">.</span><span class="n">next</span>

        <span class="k">if</span> <span class="n">ptr1</span><span class="o">.</span><span class="n">next</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">ptr1</span><span class="o">.</span><span class="n">next</span>
        <span class="n">ptr1</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">ptr1</span><span class="o">.</span><span class="n">next</span><span class="o">.</span><span class="n">next</span>
        <span class="k">del</span> <span class="n">node</span>

        <span class="k">return</span> <span class="n">head</span> 
           
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>86.Linked List Cycle</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>86.Linked List Cycle</h2>
                <p>Given head, the head of a linked list, determine if the linked list has a cycle in it.<br>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to. Note that pos is not passed as a parameter.<br>Return true if there is a cycle in the linked list. Otherwise, return false.<br> <br>Example 1:<br><br><br>Input: head = [3,2,0,-4], pos = 1<br>Output: true<br>Explanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).<br><br>Example 2:<br><br><br>Input: head = [1,2], pos = 0<br>Output: true<br>Explanation: There is a cycle in the linked list, where the tail connects to the 0th node.<br><br>Example 3:<br><br><br>Input: head = [1], pos = -1<br>Output: false<br>Explanation: There is no cycle in the linked list.<br><br> <br>Constraints:<br><br>The number of the nodes in the list is in the range [0, 104].<br>-105 <= Node.val <= 105<br>pos is -1 or a valid index in the linked-list.<br><br> <br>Follow up: Can you solve it using O(1) (i.e. constant) memory?<br></p>
                <a href=https://leetcode.com/problems/linked-list-cycle>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="c1"># Definition for singly-linked list.</span>
<span class="c1"># class ListNode:</span>
<span class="c1">#     def __init__(self, x):</span>
<span class="c1">#         self.val = x</span>
<span class="c1">#         self.next = None</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">hasCycle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">head</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">p1</span> <span class="o">=</span> <span class="n">head</span>
        <span class="n">p2</span> <span class="o">=</span> <span class="n">head</span>

        <span class="k">while</span> <span class="n">p1</span> <span class="ow">and</span> <span class="n">p2</span><span class="p">:</span>
            <span class="n">p1</span> <span class="o">=</span> <span class="n">p1</span><span class="o">.</span><span class="n">next</span>

            <span class="n">p2</span> <span class="o">=</span> <span class="n">p2</span><span class="o">.</span><span class="n">next</span>
            <span class="k">if</span> <span class="n">p2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span><span class="k">return</span> <span class="kc">False</span>
            <span class="n">p2</span> <span class="o">=</span> <span class="n">p2</span><span class="o">.</span><span class="n">next</span>

            <span class="k">if</span> <span class="n">p1</span> <span class="o">==</span> <span class="n">p2</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>87.All Paths From Source to Target</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>87.All Paths From Source to Target</h2>
                <p>Given a directed acyclic graph (DAG) of n nodes labeled from 0 to n - 1, find all possible paths from node 0 to node n - 1 and return them in any order.<br>The graph is given as follows: graph[i] is a list of all nodes you can visit from node i (i.e., there is a directed edge from node i to node graph[i][j]).<br> <br>Example 1:<br><br><br>Input: graph = [[1,2],[3],[3],[]]<br>Output: [[0,1,3],[0,2,3]]<br>Explanation: There are two paths: 0 -> 1 -> 3 and 0 -> 2 -> 3.<br><br>Example 2:<br><br><br>Input: graph = [[4,3,1],[3,2,4],[3],[4],[]]<br>Output: [[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]]<br><br> <br>Constraints:<br><br>n == graph.length<br>2 <= n <= 15<br>0 <= graph[i][j] < n<br>graph[i][j] != i (i.e., there will be no self-loops).<br>All the elements of graph[i] are unique.<br>The input graph is guaranteed to be a DAG.<br><br></p>
                <a href=https://leetcode.com/problems/all-paths-from-source-to-target>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="n">public</span><span class="p">:</span>

    <span class="n">void</span> <span class="n">dfs</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;&gt;</span> <span class="o">&amp;</span> <span class="n">graph</span><span class="p">,</span> <span class="nb">int</span> <span class="n">source</span><span class="p">,</span> <span class="nb">int</span> <span class="n">dest</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span> <span class="nb">int</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">path</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;&gt;</span> <span class="o">&amp;</span><span class="n">outputs</span><span class="p">){</span>
        <span class="n">path</span><span class="o">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">source</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">source</span> <span class="o">==</span> <span class="n">dest</span><span class="p">){</span>
            <span class="n">outputs</span><span class="o">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
            <span class="n">path</span><span class="o">.</span><span class="n">pop_back</span><span class="p">();</span>
            <span class="k">return</span> <span class="p">;</span>
        <span class="p">}</span>
        <span class="n">vector</span> <span class="o">&lt;</span> <span class="nb">int</span> <span class="o">&gt;</span> <span class="n">neighbours</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="n">source</span><span class="p">];</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">auto</span> <span class="n">val</span> <span class="p">:</span> <span class="n">neighbours</span><span class="p">){</span>
            <span class="n">this</span><span class="o">-&gt;</span><span class="n">dfs</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">outputs</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">path</span><span class="o">.</span><span class="n">pop_back</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;&gt;</span> <span class="n">allPathsSourceTarget</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">graph</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;&gt;</span> <span class="n">outputs</span><span class="p">;</span>
        <span class="nb">int</span> <span class="n">dest</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="n">vector</span><span class="o">&lt;</span> <span class="nb">int</span> <span class="o">&gt;</span> <span class="n">path</span><span class="p">;</span>
        <span class="n">this</span> <span class="o">-&gt;</span> <span class="n">dfs</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">outputs</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">outputs</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>88.Merge Two Sorted Lists</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>88.Merge Two Sorted Lists</h2>
                <p>You are given the heads of two sorted linked lists list1 and list2.<br>Merge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists.<br>Return the head of the merged linked list.<br> <br>Example 1:<br><br><br>Input: list1 = [1,2,4], list2 = [1,3,4]<br>Output: [1,1,2,3,4,4]<br><br>Example 2:<br><br>Input: list1 = [], list2 = []<br>Output: []<br><br>Example 3:<br><br>Input: list1 = [], list2 = [0]<br>Output: [0]<br><br> <br>Constraints:<br><br>The number of nodes in both lists is in the range [0, 50].<br>-100 <= Node.val <= 100<br>Both list1 and list2 are sorted in non-decreasing order.<br><br></p>
                <a href=https://leetcode.com/problems/merge-two-sorted-lists>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="c1"># Definition for singly-linked list.</span>
<span class="c1"># class ListNode:</span>
<span class="c1">#     def __init__(self, val=0, next=None):</span>
<span class="c1">#         self.val = val</span>
<span class="c1">#         self.next = next</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">mergeTwoLists</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">list1</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">],</span> <span class="n">list2</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">]:</span>
        <span class="n">dummy_head</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">()</span>

        <span class="n">c_ptr</span> <span class="o">=</span> <span class="n">dummy_head</span>
        <span class="k">while</span> <span class="n">list1</span> <span class="ow">and</span> <span class="n">list2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">list1</span><span class="o">.</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">list2</span><span class="o">.</span><span class="n">val</span><span class="p">:</span>
                <span class="n">c_ptr</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">list1</span>
                <span class="n">list1</span> <span class="o">=</span> <span class="n">list1</span><span class="o">.</span><span class="n">next</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">c_ptr</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">list2</span>
                <span class="n">list2</span> <span class="o">=</span> <span class="n">list2</span><span class="o">.</span><span class="n">next</span>
            <span class="n">c_ptr</span> <span class="o">=</span> <span class="n">c_ptr</span><span class="o">.</span><span class="n">next</span>
        
        <span class="k">if</span> <span class="n">list1</span><span class="p">:</span>
            <span class="n">c_ptr</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">list1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">c_ptr</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">list2</span>
    
        <span class="k">return</span> <span class="n">dummy_head</span><span class="o">.</span><span class="n">next</span>
        
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>89.Copy List with Random Pointer</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>89.Copy List with Random Pointer</h2>
                <p>A linked list of length n is given such that each node contains an additional random pointer, which could point to any node in the list, or null.<br>Construct a deep copy of the list. The deep copy should consist of exactly n brand new nodes, where each new node has its value set to the value of its corresponding original node. Both the next and random pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. None of the pointers in the new list should point to nodes in the original list.<br>For example, if there are two nodes X and Y in the original list, where X.random --> Y, then for the corresponding two nodes x and y in the copied list, x.random --> y.<br>Return the head of the copied linked list.<br>The linked list is represented in the input/output as a list of n nodes. Each node is represented as a pair of [val, random_index] where:<br><br>val: an integer representing Node.val<br>random_index: the index of the node (range from 0 to n-1) that the random pointer points to, or null if it does not point to any node.<br><br>Your code will only be given the head of the original linked list.<br> <br>Example 1:<br><br><br>Input: head = [[7,null],[13,0],[11,4],[10,2],[1,0]]<br>Output: [[7,null],[13,0],[11,4],[10,2],[1,0]]<br><br>Example 2:<br><br><br>Input: head = [[1,1],[2,1]]<br>Output: [[1,1],[2,1]]<br><br>Example 3:<br><br><br>Input: head = [[3,null],[3,0],[3,null]]<br>Output: [[3,null],[3,0],[3,null]]<br><br> <br>Constraints:<br><br>0 <= n <= 1000<br>-104 <= Node.val <= 104<br>Node.random is null or is pointing to some node in the linked list.<br><br></p>
                <a href=https://leetcode.com/problems/copy-list-with-random-pointer>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd"># Definition for a Node.</span>
<span class="sd">class Node:</span>
<span class="sd">    def __init__(self, x: int, next: &#39;Node&#39; = None, random: &#39;Node&#39; = None):</span>
<span class="sd">        self.val = int(x)</span>
<span class="sd">        self.next = next</span>
<span class="sd">        self.random = random</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">copyRandomList</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">head</span><span class="p">:</span> <span class="s1">&#39;Optional[Node]&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Optional[Node]&#39;</span><span class="p">:</span>
        <span class="n">dummy_head</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        
        <span class="n">new_ptr</span> <span class="o">=</span> <span class="n">dummy_head</span>
        <span class="n">old_ptr</span> <span class="o">=</span> <span class="n">head</span>
        
        <span class="n">node_map</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">while</span> <span class="n">old_ptr</span><span class="p">:</span>
            <span class="n">new_node</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">old_ptr</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
            <span class="n">new_ptr</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">new_node</span>
            
            <span class="n">node_map</span><span class="p">[</span><span class="n">old_ptr</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_node</span>
            <span class="n">old_ptr</span> <span class="o">=</span> <span class="n">old_ptr</span><span class="o">.</span><span class="n">next</span>
            <span class="n">new_ptr</span> <span class="o">=</span> <span class="n">new_ptr</span><span class="o">.</span><span class="n">next</span>
            
            
        
        <span class="n">old_ptr</span> <span class="o">=</span> <span class="n">head</span>
        <span class="n">new_ptr</span> <span class="o">=</span> <span class="n">dummy_head</span><span class="o">.</span><span class="n">next</span>
        <span class="c1"># add random nodes links</span>
        <span class="k">while</span> <span class="n">old_ptr</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">old_ptr</span><span class="o">.</span><span class="n">random</span><span class="p">:</span>
                <span class="n">new_rand_node</span> <span class="o">=</span> <span class="n">node_map</span><span class="p">[</span><span class="n">old_ptr</span><span class="o">.</span><span class="n">random</span><span class="p">]</span>
                <span class="n">new_ptr</span><span class="o">.</span><span class="n">random</span> <span class="o">=</span> <span class="n">new_rand_node</span>
            <span class="n">old_ptr</span> <span class="o">=</span> <span class="n">old_ptr</span><span class="o">.</span><span class="n">next</span>
            <span class="n">new_ptr</span> <span class="o">=</span> <span class="n">new_ptr</span><span class="o">.</span><span class="n">next</span>
        <span class="k">return</span> <span class="n">dummy_head</span><span class="o">.</span><span class="n">next</span>
            
            
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>90.Counting Bits</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>90.Counting Bits</h2>
                <p>Given an integer n, return an array ans of length n + 1 such that for each i (0 <= i <= n), ans[i] is the number of 1's in the binary representation of i.<br> <br>Example 1:<br><br>Input: n = 2<br>Output: [0,1,1]<br>Explanation:<br>0 --> 0<br>1 --> 1<br>2 --> 10<br><br>Example 2:<br><br>Input: n = 5<br>Output: [0,1,1,2,1,2]<br>Explanation:<br>0 --> 0<br>1 --> 1<br>2 --> 10<br>3 --> 11<br>4 --> 100<br>5 --> 101<br><br> <br>Constraints:<br><br>0 <= n <= 105<br><br> <br>Follow up:<br><br>It is very easy to come up with a solution with a runtime of O(n log n). Can you do it in linear time O(n) and possibly in a single pass?<br>Can you do it without using any built-in function (i.e., like __builtin_popcount in C++)?<br><br></p>
                <a href=https://leetcode.com/problems/counting-bits>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    0 = 0000</span>
<span class="sd">    1 = 0001</span>
<span class="sd">    2 = 0010</span>
<span class="sd">    3 = 0011</span>
<span class="sd">    4 = 0100</span>
<span class="sd">    5 = 0101</span>
<span class="sd">    6 = 0110</span>
<span class="sd">    7 = 0111</span>


<span class="sd">    0 = 0</span>
<span class="sd">    1 = 1</span>
<span class="sd">    2 = 1</span>
<span class="sd">    3 = 2</span>
<span class="sd">    4 = 1</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">countBits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">n</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">output</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">output</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">:</span>
                <span class="n">output</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="n">i</span><span class="o">//</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">output</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="n">i</span><span class="o">//</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span>
        <span class="k">return</span> <span class="n">output</span>

        
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>91.Word Search II</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>91.Word Search II</h2>
                <p>Given an m x n board of characters and a list of strings words, return all words on the board.<br>Each word must be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.<br> <br>Example 1:<br><br><br>Input: board = [["o","a","a","n"],["e","t","a","e"],["i","h","k","r"],["i","f","l","v"]], words = ["oath","pea","eat","rain"]<br>Output: ["eat","oath"]<br><br>Example 2:<br><br><br>Input: board = [["a","b"],["c","d"]], words = ["abcb"]<br>Output: []<br><br> <br>Constraints:<br><br>m == board.length<br>n == board[i].length<br>1 <= m, n <= 12<br>board[i][j] is a lowercase English letter.<br>1 <= words.length <= 3 * 104<br>1 <= words[i].length <= 10<br>words[i] consists of lowercase English letters.<br>All the strings of words are unique.<br><br></p>
                <a href=https://leetcode.com/problems/word-search-ii>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">childs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_word</span> <span class="o">=</span> <span class="kc">False</span>

<span class="k">class</span> <span class="nc">Trie</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">Node</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">add_word</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">):</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">word</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">childs</span><span class="p">:</span>
                <span class="n">node</span><span class="o">.</span><span class="n">childs</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">Node</span><span class="p">()</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">childs</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
        <span class="n">node</span><span class="o">.</span><span class="n">is_word</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">def</span> <span class="nf">add_words</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">words</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">words</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_word</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">board</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">word</span><span class="p">):</span>
        <span class="n">ROWS</span><span class="p">,</span> <span class="n">COLS</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">board</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">board</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">r</span><span class="p">,</span><span class="n">c</span> <span class="o">=</span> <span class="n">pos</span>
        <span class="n">char</span> <span class="o">=</span> <span class="n">board</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]</span>
        
        <span class="n">word</span> <span class="o">+=</span> <span class="n">char</span>
        <span class="c1"># print (r,c, word, root.is_word)</span>
        <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">is_word</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
            <span class="n">root</span><span class="o">.</span><span class="n">is_word</span> <span class="o">=</span> <span class="kc">False</span>
        
        <span class="n">visited</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">dr</span><span class="p">,</span><span class="n">dc</span> <span class="ow">in</span> <span class="p">[</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)]:</span>
            <span class="n">r1</span><span class="p">,</span> <span class="n">c1</span> <span class="o">=</span> <span class="n">r</span><span class="o">+</span><span class="n">dr</span><span class="p">,</span> <span class="n">c</span><span class="o">+</span><span class="n">dc</span>
            <span class="k">if</span> <span class="mi">0</span><span class="o">&lt;=</span><span class="n">r1</span><span class="o">&lt;</span><span class="n">ROWS</span> <span class="ow">and</span> <span class="mi">0</span><span class="o">&lt;=</span><span class="n">c1</span><span class="o">&lt;</span><span class="n">COLS</span> <span class="ow">and</span> <span class="n">visited</span><span class="p">[</span><span class="n">r1</span><span class="p">][</span><span class="n">c1</span><span class="p">]</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
                <span class="n">char1</span> <span class="o">=</span> <span class="n">board</span><span class="p">[</span><span class="n">r1</span><span class="p">][</span><span class="n">c1</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">char1</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">childs</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">dfs</span><span class="p">((</span><span class="n">r1</span><span class="p">,</span><span class="n">c1</span><span class="p">),</span> <span class="n">board</span><span class="p">,</span> <span class="n">root</span><span class="o">.</span><span class="n">childs</span><span class="p">[</span><span class="n">char1</span><span class="p">],</span> <span class="n">visited</span><span class="p">,</span> <span class="n">word</span><span class="p">)</span>
        <span class="n">visited</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">findWords</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">board</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">words</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="n">trie</span> <span class="o">=</span> <span class="n">Trie</span><span class="p">()</span>
        <span class="n">trie</span><span class="o">.</span><span class="n">add_words</span><span class="p">(</span><span class="n">words</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">ROWS</span><span class="p">,</span> <span class="n">COLS</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">board</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">board</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="p">[</span> <span class="p">[</span><span class="kc">False</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">COLS</span><span class="p">)]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ROWS</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ROWS</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">COLS</span><span class="p">):</span>
                
                <span class="n">char</span> <span class="o">=</span> <span class="n">board</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">trie</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">childs</span><span class="p">:</span>
                    <span class="n">root</span> <span class="o">=</span> <span class="n">trie</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">childs</span><span class="p">[</span><span class="n">char</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">dfs</span><span class="p">(</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">),</span> <span class="n">board</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">word</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">output</span>
            
        
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>92.Valid Anagram</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>92.Valid Anagram</h2>
                <p>Given two strings s and t, return true if t is an anagram of s, and false otherwise.<br>An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.<br> <br>Example 1:<br>Input: s = "anagram", t = "nagaram"<br>Output: true<br>Example 2:<br>Input: s = "rat", t = "car"<br>Output: false<br><br> <br>Constraints:<br><br>1 <= s.length, t.length <= 5 * 104<br>s and t consist of lowercase English letters.<br><br> <br>Follow up: What if the inputs contain Unicode characters? How would you adapt your solution to such a case?<br></p>
                <a href=https://leetcode.com/problems/valid-anagram>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">isAnagram</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">char_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
            <span class="n">char_dict</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">char_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">t</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">char_dict</span><span class="p">:</span>
                <span class="n">char_dict</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">-=</span><span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">char_dict</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">char_dict</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">char_dict</span><span class="p">):</span><span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>93.Valid Sudoku</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>93.Valid Sudoku</h2>
                <p>Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:<br><br>Each row must contain the digits 1-9 without repetition.<br>Each column must contain the digits 1-9 without repetition.<br>Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.<br><br>Note:<br><br>A Sudoku board (partially filled) could be valid but is not necessarily solvable.<br>Only the filled cells need to be validated according to the mentioned rules.<br><br> <br>Example 1:<br><br><br>Input: board = <br>[["5","3",".",".","7",".",".",".","."]<br>,["6",".",".","1","9","5",".",".","."]<br>,[".","9","8",".",".",".",".","6","."]<br>,["8",".",".",".","6",".",".",".","3"]<br>,["4",".",".","8",".","3",".",".","1"]<br>,["7",".",".",".","2",".",".",".","6"]<br>,[".","6",".",".",".",".","2","8","."]<br>,[".",".",".","4","1","9",".",".","5"]<br>,[".",".",".",".","8",".",".","7","9"]]<br>Output: true<br><br>Example 2:<br><br>Input: board = <br>[["8","3",".",".","7",".",".",".","."]<br>,["6",".",".","1","9","5",".",".","."]<br>,[".","9","8",".",".",".",".","6","."]<br>,["8",".",".",".","6",".",".",".","3"]<br>,["4",".",".","8",".","3",".",".","1"]<br>,["7",".",".",".","2",".",".",".","6"]<br>,[".","6",".",".",".",".","2","8","."]<br>,[".",".",".","4","1","9",".",".","5"]<br>,[".",".",".",".","8",".",".","7","9"]]<br>Output: false<br>Explanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid.<br><br> <br>Constraints:<br><br>board.length == 9<br>board[i].length == 9<br>board[i][j] is a digit 1-9 or '.'.<br><br></p>
                <a href=https://leetcode.com/problems/valid-sudoku>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="n">public</span><span class="p">:</span>
    <span class="nb">bool</span> <span class="n">isValidSudoku</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">char</span><span class="o">&gt;&gt;&amp;</span> <span class="n">board</span><span class="p">)</span> <span class="p">{</span>
        <span class="nb">int</span> <span class="n">ROWS</span> <span class="o">=</span> <span class="n">board</span><span class="o">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">COLS</span><span class="o">=</span> <span class="n">board</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">();</span>

        <span class="o">//</span> <span class="n">check</span> <span class="n">rows</span> <span class="n">first</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">char</span><span class="o">&gt;&gt;</span> <span class="n">nums_set_box</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">char</span> <span class="o">&gt;</span><span class="p">()</span> <span class="p">);</span>
        <span class="k">for</span><span class="p">(</span><span class="nb">int</span> <span class="n">r</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">ROWS</span><span class="p">;</span> <span class="n">r</span><span class="o">++</span><span class="p">){</span>
            <span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">char</span><span class="o">&gt;</span> <span class="n">nums_set_rows</span><span class="p">;</span>
            <span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">char</span><span class="o">&gt;</span> <span class="n">nums_set_cols</span><span class="p">;</span>
        
            <span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">c</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">COLS</span><span class="p">;</span> <span class="n">c</span><span class="o">++</span><span class="p">){</span>
                <span class="n">char</span> <span class="n">val_row</span> <span class="o">=</span> <span class="n">board</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">];</span>
                <span class="n">char</span> <span class="n">val_col</span> <span class="o">=</span> <span class="n">board</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="n">r</span><span class="p">];</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">nums_set_rows</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">val_row</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nums_set_rows</span><span class="o">.</span><span class="n">end</span><span class="p">()</span> <span class="o">||</span>
                    <span class="n">nums_set_cols</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">val_col</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nums_set_cols</span><span class="o">.</span><span class="n">end</span><span class="p">()</span> <span class="p">){</span>
                    <span class="k">return</span> <span class="n">false</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="o">//</span> <span class="n">box</span> <span class="n">indexs</span>
                <span class="nb">int</span> <span class="n">br</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">r</span><span class="o">/</span><span class="mi">3</span><span class="p">);</span>
                <span class="nb">int</span> <span class="n">bc</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">c</span><span class="o">/</span><span class="mi">3</span><span class="p">);</span>
                <span class="nb">int</span> <span class="n">box_idx</span> <span class="o">=</span> <span class="n">br</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="n">bc</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span> <span class="n">nums_set_box</span><span class="p">[</span><span class="n">box_idx</span><span class="p">]</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">val_row</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nums_set_box</span><span class="p">[</span><span class="n">box_idx</span><span class="p">]</span><span class="o">.</span><span class="n">end</span><span class="p">()</span> <span class="p">){</span>
                    <span class="k">return</span> <span class="n">false</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">val_row</span> <span class="o">!=</span><span class="s1">&#39;.&#39;</span><span class="p">){</span>
                    <span class="n">nums_set_rows</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">val_row</span><span class="p">);</span>
                    <span class="n">nums_set_box</span><span class="p">[</span><span class="n">box_idx</span><span class="p">]</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">val_row</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">val_col</span> <span class="o">!=</span><span class="s1">&#39;.&#39;</span><span class="p">){</span>
                    <span class="n">nums_set_cols</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">val_col</span><span class="p">);</span>
                <span class="p">}</span>
                
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">true</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>94.Same Tree</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>94.Same Tree</h2>
                <p>Given the roots of two binary trees p and q, write a function to check if they are the same or not.<br>Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.<br> <br>Example 1:<br><br><br>Input: p = [1,2,3], q = [1,2,3]<br>Output: true<br><br>Example 2:<br><br><br>Input: p = [1,2], q = [1,null,2]<br>Output: false<br><br>Example 3:<br><br><br>Input: p = [1,2,1], q = [1,1,2]<br>Output: false<br><br> <br>Constraints:<br><br>The number of nodes in both trees is in the range [0, 100].<br>-104 <= Node.val <= 104<br><br></p>
                <a href=https://leetcode.com/problems/same-tree>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="c1"># Definition for a binary tree node.</span>
<span class="c1"># class TreeNode:</span>
<span class="c1">#     def __init__(self, val=0, left=None, right=None):</span>
<span class="c1">#         self.val = val</span>
<span class="c1">#         self.left = left</span>
<span class="c1">#         self.right = right</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">isSameTree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">q</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">p</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">q</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        
        <span class="k">if</span> <span class="p">(</span> <span class="n">p</span> <span class="o">==</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">q</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">q</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">val</span> <span class="o">!=</span> <span class="n">q</span><span class="o">.</span><span class="n">val</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        
        <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">isSameTree</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
        <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">isSameTree</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">left</span> <span class="ow">and</span> <span class="n">right</span>
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>95.Reorder List</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>95.Reorder List</h2>
                <p>You are given the head of a singly linked-list. The list can be represented as:<br><br>L0 → L1 → … → Ln - 1 → Ln<br><br>Reorder the list to be on the following form:<br><br>L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …<br><br>You may not modify the values in the list's nodes. Only nodes themselves may be changed.<br> <br>Example 1:<br><br><br>Input: head = [1,2,3,4]<br>Output: [1,4,2,3]<br><br>Example 2:<br><br><br>Input: head = [1,2,3,4,5]<br>Output: [1,5,2,4,3]<br><br> <br>Constraints:<br><br>The number of nodes in the list is in the range [1, 5 * 104].<br>1 <= Node.val <= 1000<br><br></p>
                <a href=https://leetcode.com/problems/reorder-list>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="c1"># Definition for singly-linked list.</span>
<span class="c1"># class ListNode:</span>
<span class="c1">#     def __init__(self, val=0, next=None):</span>
<span class="c1">#         self.val = val</span>
<span class="c1">#         self.next = next</span>
<span class="c1"># </span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">reorderList</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">head</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Do not return anything, modify head in-place instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">get_len</span><span class="p">(</span><span class="n">head</span><span class="p">):</span>
            <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span> 
            <span class="k">while</span> <span class="n">head</span><span class="p">:</span>
                <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="n">next</span>
                <span class="n">n</span> <span class="o">+=</span><span class="mi">1</span>
            <span class="k">return</span> <span class="n">n</span>
        
        <span class="k">def</span> <span class="nf">print_list</span><span class="p">(</span><span class="n">head</span><span class="p">):</span>
            <span class="n">head1</span> <span class="o">=</span> <span class="n">head</span>
            <span class="k">while</span> <span class="n">head1</span><span class="p">:</span>
                <span class="nb">print</span> <span class="p">(</span><span class="n">head1</span><span class="o">.</span><span class="n">val</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="s2">&quot;-&gt;&quot;</span><span class="p">)</span>
                <span class="n">head1</span> <span class="o">=</span> <span class="n">head1</span><span class="o">.</span><span class="n">next</span>
            <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)</span>

        <span class="n">head1</span> <span class="o">=</span> <span class="n">head</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">get_len</span><span class="p">(</span><span class="n">head1</span><span class="p">)</span>
        <span class="n">first_list</span> <span class="o">=</span> <span class="n">head</span>
        <span class="n">second_list</span> <span class="o">=</span> <span class="n">head</span>
        <span class="n">middle_index</span> <span class="o">=</span> <span class="n">n</span><span class="o">//</span><span class="mi">2</span>

        <span class="n">middle_node</span> <span class="o">=</span> <span class="n">head</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">middle_index</span><span class="p">):</span>
            <span class="n">middle_node</span> <span class="o">=</span> <span class="n">middle_node</span><span class="o">.</span><span class="n">next</span>
        
        <span class="n">second_list</span> <span class="o">=</span> <span class="n">middle_node</span><span class="o">.</span><span class="n">next</span>
        <span class="n">middle_node</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="kc">None</span>
        
        <span class="c1"># reverse_the_list</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">second_list</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">while</span> <span class="n">curr</span><span class="p">:</span>
            <span class="n">next_ptr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="n">next</span>
            <span class="n">curr</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">prev</span>
            <span class="n">prev</span> <span class="o">=</span> <span class="n">curr</span>
            <span class="n">curr</span> <span class="o">=</span> <span class="n">next_ptr</span>
        <span class="n">reversed_half</span> <span class="o">=</span> <span class="n">prev</span>
        <span class="n">second_list</span> <span class="o">=</span> <span class="n">reversed_half</span>
        
        <span class="c1"># print_list(head)</span>
        <span class="c1"># print_list(second_list)</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        1 2 3 4</span>
<span class="sd">        5 6 7</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">while</span> <span class="n">second_list</span><span class="p">:</span>
            <span class="n">first_next</span> <span class="o">=</span> <span class="n">first_list</span><span class="o">.</span><span class="n">next</span> <span class="c1"># 2</span>
            <span class="n">second_next</span> <span class="o">=</span> <span class="n">second_list</span><span class="o">.</span><span class="n">next</span> <span class="c1"># 6</span>

            <span class="n">first_list</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">second_list</span> <span class="c1"># 1-&gt;5 </span>
            <span class="n">second_list</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">first_next</span> <span class="c1"># 5-&gt;2</span>

            <span class="n">second_list</span> <span class="o">=</span> <span class="n">second_next</span> <span class="c1"># 6</span>
            <span class="n">first_list</span> <span class="o">=</span> <span class="n">first_next</span> <span class="c1"># 2</span>

            <span class="nb">print</span> <span class="p">()</span>
        
        <span class="k">return</span> <span class="n">head1</span>




        

        
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>96.Number of 1 Bits</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>96.Number of 1 Bits</h2>
                <p>Write a function that takes the binary representation of a positive integer and returns the number of set bits it has (also known as the Hamming weight).<br> <br>Example 1:<br><br>Input: n = 11<br>Output: 3<br>Explanation:<br>The input binary string 1011 has a total of three set bits.<br><br>Example 2:<br><br>Input: n = 128<br>Output: 1<br>Explanation:<br>The input binary string 10000000 has a total of one set bit.<br><br>Example 3:<br><br>Input: n = 2147483645<br>Output: 30<br>Explanation:<br>The input binary string 1111111111111111111111111111101 has a total of thirty set bits.<br><br> <br>Constraints:<br><br>1 <= n <= 231 - 1<br><br> <br>Follow up: If this function is called many times, how would you optimize it?</p>
                <a href=https://leetcode.com/problems/number-of-1-bits>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">hammingWeight</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">:</span><span class="k">return</span> <span class="mi">1</span>
    

        <span class="k">def</span> <span class="nf">count1</span><span class="p">(</span> <span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">n</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">n</span><span class="o">==</span><span class="mi">1</span> <span class="p">:</span> <span class="k">return</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">n</span><span class="o">%</span><span class="mi">2</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">count1</span><span class="p">(</span><span class="n">n</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">count1</span><span class="p">(</span><span class="n">n</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">count1</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>97.Add Two Numbers</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>97.Add Two Numbers</h2>
                <p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.<br>You may assume the two numbers do not contain any leading zero, except the number 0 itself.<br> <br>Example 1:<br><br><br>Input: l1 = [2,4,3], l2 = [5,6,4]<br>Output: [7,0,8]<br>Explanation: 342 + 465 = 807.<br><br>Example 2:<br><br>Input: l1 = [0], l2 = [0]<br>Output: [0]<br><br>Example 3:<br><br>Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]<br>Output: [8,9,9,9,0,0,0,1]<br><br> <br>Constraints:<br><br>The number of nodes in each linked list is in the range [1, 100].<br>0 <= Node.val <= 9<br>It is guaranteed that the list represents a number that does not have leading zeros.<br><br></p>
                <a href=https://leetcode.com/problems/add-two-numbers>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="c1"># Definition for singly-linked list.</span>
<span class="c1"># class ListNode:</span>
<span class="c1">#     def __init__(self, val=0, next=None):</span>
<span class="c1">#         self.val = val</span>
<span class="c1">#         self.next = next</span>
<span class="c1"># l1 = [2,4,], l2 = [5,6,]</span>
<span class="c1">#</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">addTwoNumbers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l1</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">],</span> <span class="n">l2</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">]:</span>
        <span class="n">result_node</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">()</span>
        
        <span class="n">r_ptr</span> <span class="o">=</span> <span class="n">result_node</span>
        <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">l1</span> <span class="ow">or</span> <span class="n">l2</span> <span class="ow">or</span> <span class="n">c</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span><span class="mi">0</span> 
            <span class="k">if</span> <span class="n">l1</span><span class="p">:</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">l1</span><span class="o">.</span><span class="n">val</span>
                <span class="n">l1</span> <span class="o">=</span> <span class="n">l1</span><span class="o">.</span><span class="n">next</span>
            <span class="k">if</span> <span class="n">l2</span><span class="p">:</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">l2</span><span class="o">.</span><span class="n">val</span>
                <span class="n">l2</span> <span class="o">=</span> <span class="n">l2</span><span class="o">.</span><span class="n">next</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">+</span><span class="n">c</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">s</span><span class="o">//</span><span class="mi">10</span>
            <span class="n">r_ptr</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">(</span><span class="n">s</span><span class="o">%</span><span class="mi">10</span><span class="p">)</span>
            <span class="n">r_ptr</span> <span class="o">=</span> <span class="n">r_ptr</span><span class="o">.</span><span class="n">next</span>
        <span class="k">return</span> <span class="n">result_node</span><span class="o">.</span><span class="n">next</span>
            
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>98.Container With Most Water</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>98.Container With Most Water</h2>
                <p>You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).<br>Find two lines that together with the x-axis form a container, such that the container contains the most water.<br>Return the maximum amount of water a container can store.<br>Notice that you may not slant the container.<br> <br>Example 1:<br><br><br>Input: height = [1,8,6,2,5,4,8,3,7]<br>Output: 49<br>Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.<br><br>Example 2:<br><br>Input: height = [1,1]<br>Output: 1<br><br> <br>Constraints:<br><br>n == height.length<br>2 <= n <= 105<br>0 <= height[i] <= 104<br><br></p>
                <a href=https://leetcode.com/problems/container-with-most-water>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">maxArea</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">height</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">e</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">height</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
        <span class="n">max_area</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">s</span> <span class="o">&lt;</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">area</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">height</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">height</span><span class="p">[</span><span class="n">e</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">e</span><span class="o">-</span><span class="n">s</span><span class="p">)</span>
            <span class="n">max_area</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_area</span><span class="p">,</span> <span class="n">area</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">height</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">height</span><span class="p">[</span><span class="n">e</span><span class="p">]:</span>
                <span class="n">s</span> <span class="o">+=</span><span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">e</span><span class="o">-=</span><span class="mi">1</span>

        <span class="k">return</span> <span class="n">max_area</span>
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>99.Word Search</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>99.Word Search</h2>
                <p>Given an m x n grid of characters board and a string word, return true if word exists in the grid.<br>The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.<br> <br>Example 1:<br><br><br>Input: board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"<br>Output: true<br><br>Example 2:<br><br><br>Input: board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "SEE"<br>Output: true<br><br>Example 3:<br><br><br>Input: board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCB"<br>Output: false<br><br> <br>Constraints:<br><br>m == board.length<br>n = board[i].length<br>1 <= m, n <= 6<br>1 <= word.length <= 15<br>board and word consists of only lowercase and uppercase English letters.<br><br> <br>Follow up: Could you use search pruning to make your solution faster with a larger board?<br></p>
                <a href=https://leetcode.com/problems/word-search>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">board</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">word</span><span class="p">,</span> <span class="n">visited</span><span class="p">):</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">board</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">board</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">r</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">pos</span>

        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="p">(</span> <span class="mi">0</span><span class="o">&lt;=</span><span class="n">r</span><span class="o">&lt;</span><span class="n">n</span> <span class="ow">and</span> <span class="mi">0</span><span class="o">&lt;=</span><span class="n">c</span><span class="o">&lt;</span><span class="n">m</span><span class="p">))</span> <span class="ow">or</span> <span class="n">visited</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]:</span>
            <span class="k">return</span> <span class="kc">False</span>
        
        <span class="k">if</span> <span class="n">board</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">!=</span> <span class="n">word</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">return</span> <span class="kc">False</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">word</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">word</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="n">board</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]:</span>
            <span class="k">return</span> <span class="kc">True</span>
        
        <span class="n">visited</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">dr</span><span class="p">,</span> <span class="n">dc</span> <span class="ow">in</span> <span class="p">[</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]:</span>
            <span class="n">r1</span><span class="p">,</span> <span class="n">c1</span> <span class="o">=</span> <span class="n">r</span><span class="o">+</span><span class="n">dr</span><span class="p">,</span> <span class="n">c</span><span class="o">+</span><span class="n">dc</span>
            <span class="n">found</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dfs</span><span class="p">(</span><span class="n">board</span><span class="p">,</span> <span class="p">(</span><span class="n">r1</span><span class="p">,</span><span class="n">c1</span><span class="p">),</span> <span class="n">word</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">visited</span><span class="p">)</span> 
            <span class="k">if</span> <span class="n">found</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="n">visited</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">exist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">board</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">word</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        
        <span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">board</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">board</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
                <span class="n">visited</span> <span class="o">=</span> <span class="p">[</span> <span class="p">[</span><span class="kc">False</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">)]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
                <span class="n">found</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dfs</span><span class="p">(</span><span class="n">board</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">),</span> <span class="n">word</span><span class="p">,</span> <span class="n">visited</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">visited</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">found</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>100.Merge Sorted Array</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>100.Merge Sorted Array</h2>
                <p>You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.<br>Merge nums1 and nums2 into a single array sorted in non-decreasing order.<br>The final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n.<br> <br>Example 1:<br><br>Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3<br>Output: [1,2,2,3,5,6]<br>Explanation: The arrays we are merging are [1,2,3] and [2,5,6].<br>The result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1.<br><br>Example 2:<br><br>Input: nums1 = [1], m = 1, nums2 = [], n = 0<br>Output: [1]<br>Explanation: The arrays we are merging are [1] and [].<br>The result of the merge is [1].<br><br>Example 3:<br><br>Input: nums1 = [0], m = 0, nums2 = [1], n = 1<br>Output: [1]<br>Explanation: The arrays we are merging are [] and [1].<br>The result of the merge is [1].<br>Note that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1.<br><br> <br>Constraints:<br><br>nums1.length == m + n<br>nums2.length == n<br>0 <= m, n <= 200<br>1 <= m + n <= 200<br>-109 <= nums1[i], nums2[j] <= 109<br><br> <br>Follow up: Can you come up with an algorithm that runs in O(m + n) time?<br></p>
                <a href=https://leetcode.com/problems/merge-sorted-array>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums1</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">m</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">nums2</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Do not return anything, modify nums1 in-place instead.</span>
<span class="sd">        [ 1 5 7 8 , 11, 0  0  0 0]</span>
<span class="sd">        [ 1 2 3 5 , 7, 8  9  10 11]</span>
<span class="sd">        [2, 3, 9, 10]</span>
<span class="sd">        ]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">i</span><span class="o">=</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span>
        <span class="n">p1</span> <span class="o">=</span> <span class="n">n</span><span class="o">+</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span>
        <span class="k">while</span> <span class="n">j</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">nums1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">nums2</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                <span class="n">nums1</span><span class="p">[</span><span class="n">p1</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">i</span><span class="o">-=</span><span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">nums1</span><span class="p">[</span><span class="n">p1</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums2</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">j</span><span class="o">-=</span><span class="mi">1</span>
            <span class="n">p1</span> <span class="o">-=</span><span class="mi">1</span>
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    <div class="solution">
    <center><h2>101.Coin Change</h2></center>
       <table>
        <tr>
            <td>
            <div class="description">
                <h2>101.Coin Change</h2>
                <p>You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.<br>Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.<br>You may assume that you have an infinite number of each kind of coin.<br> <br>Example 1:<br><br>Input: coins = [1,2,5], amount = 11<br>Output: 3<br>Explanation: 11 = 5 + 5 + 1<br><br>Example 2:<br><br>Input: coins = [2], amount = 3<br>Output: -1<br><br>Example 3:<br><br>Input: coins = [1], amount = 0<br>Output: 0<br><br> <br>Constraints:<br><br>1 <= coins.length <= 12<br>1 <= coins[i] <= 231 - 1<br>0 <= amount <= 104<br><br></p>
                <a href=https://leetcode.com/problems/coin-change>Link</a>
                </div>
            </td>
        <td>
        </div>
            <div class="code"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    [1, 2] = 3</span>

<span class="sd">    1  </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">coin_change</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coins</span><span class="p">,</span> <span class="n">amount</span> <span class="p">):</span>
        <span class="k">if</span> <span class="n">amount</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">memo</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">memo</span><span class="p">[</span><span class="n">amount</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">amount</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">memo</span><span class="p">[</span><span class="n">amount</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">amount</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">:</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span>
        
        <span class="n">min_changes</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">coin</span> <span class="ow">in</span> <span class="n">coins</span><span class="p">:</span>
            <span class="n">changes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coin_change</span><span class="p">(</span><span class="n">coins</span><span class="p">,</span> <span class="n">amount</span><span class="o">-</span><span class="n">coin</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="c1">#print (amount , coin , changes)</span>
            <span class="n">min_changes</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">min_changes</span><span class="p">,</span> <span class="n">changes</span><span class="p">)</span> 
        
        <span class="bp">self</span><span class="o">.</span><span class="n">memo</span><span class="p">[</span><span class="n">amount</span><span class="p">]</span> <span class="o">=</span> <span class="n">min_changes</span> 
        <span class="c1">#print (amount, self.memo[amount])</span>
        <span class="k">return</span> <span class="n">min_changes</span>

    <span class="k">def</span> <span class="nf">coinChange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coins</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">amount</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">memo</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coin_change</span><span class="p">(</span><span class="n">coins</span><span class="p">,</span> <span class="n">amount</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">memo</span><span class="p">[</span><span class="n">amount</span><span class="p">]</span> <span class="o">==</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">memo</span><span class="p">[</span><span class="n">amount</span><span class="p">]</span> 
</pre></div>
        </div>
        </td>
    </tr>
    </table>
    
</body>
</html>
